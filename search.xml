<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[内存对齐那点事]]></title>
      <url>/2020/07/21/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p><img src="/images/Memory-alignment/memory-cover.jpg" alt="post-cover"></p>
<p>参考链接：<a href="https://levphy.github.io/2017/03/23/memory-alignment.html" target="_blank" rel="external">内存对齐规则之我见-作者:Levphy</a></p>
<p>此篇博客主要阐述知识点—内存对齐。<br>目录一览：</p>
<blockquote>
<ul>
<li>为什么要求内存对齐?</li>
<li>内存对齐三大规则</li>
<li>包含共同体类型变量的内存对齐</li>
<li>规则之外的例子</li>
</ul>
</blockquote>
<h2 id="一、为什么要求内存对齐"><a href="#一、为什么要求内存对齐" class="headerlink" title="一、为什么要求内存对齐?"></a>一、为什么要求内存对齐?</h2><p><strong>主要原因如下:</strong></p>
<blockquote>
<ul>
<li>节省内存空间,提升程序性能</li>
<li>考虑兼容性,便于平台移植</li>
</ul>
</blockquote>
<h2 id="二、内存对齐三大规则"><a href="#二、内存对齐三大规则" class="headerlink" title="二、内存对齐三大规则"></a>二、内存对齐三大规则</h2><p>首先考虑以下实例:</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
struct A{
    char a;
    int b;
    short c;
};

struct B{
    short c;
    char a;
    int b;
};
int main(){
    cout&lt;&lt;sizeof(A)&lt;&lt;endl;
    cout&lt;&lt;sizeof(B)&lt;&lt;endl;
    return 0;
}
</code></pre><p>上面两个结构体A和B成员变量类型相同，但是占用的内存空间大小(单位:字节)却不一样。<br><strong>sizeof(A) = 12</strong><br><strong>sizeof(B) = 8</strong><br>为了分析造成这种现象的原因，我们不得不提及内存对齐的<strong>三大规则</strong>:</p>
<blockquote>
<ul>
<li>对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍;</li>
<li>结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍;</li>
<li>如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型</li>
</ul>
</blockquote>
<p>以上面结构体A为例，第一个成员a是char类型，占用1个字节空间，偏移量为0，第二个成员b是int类型，占用4个字节空间，按照规则1，b的偏移量必须是int类型的整数倍，所以编译器会在a变量后面插入3字节缓冲区，保证此时b的偏移量(4字节)是b类型的整数倍(当前恰好是1倍)，第3个成员c为short类型，此时c的偏移量正好是4+4=8个字节，已经是short类型的整数倍，故b与c之间不用填充缓冲字节。但这时，结构体A的大小为8+2=10个字节，按照规则2，结构体A大小必须是其最大成员类型int的整数倍，所以在10个字节的基础上再填充2个字节，保证最后结构体大小为12，以符合规则2。</p>
<table>
<thead>
<tr>
<th>数据成员</th>
<th style="text-align:center">前面偏移量</th>
<th>成员自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>(char) a</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td><strong>1</strong></td>
<td></td>
</tr>
<tr>
<td><strong>缓冲补齐</strong></td>
<td style="text-align:center"><strong>1</strong></td>
<td><strong>3（规则1）</strong></td>
<td></td>
</tr>
<tr>
<td><strong>(int) b</strong></td>
<td style="text-align:center"><strong>4</strong></td>
<td><strong>4</strong></td>
<td></td>
</tr>
<tr>
<td><strong>(short) c</strong></td>
<td style="text-align:center"><strong>8</strong></td>
<td><strong>2</strong></td>
<td></td>
</tr>
<tr>
<td><strong>缓存补齐</strong></td>
<td style="text-align:center"><strong>10</strong></td>
<td><strong>2（规则2）</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>类似的，结构体B成员的分析如下：</p>
<table>
<thead>
<tr>
<th>数据成员</th>
<th style="text-align:center">前面偏移量</th>
<th>成员自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>(char) c</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td><strong>2</strong></td>
<td></td>
</tr>
<tr>
<td><strong>(char) a</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td><strong>1</strong></td>
<td></td>
</tr>
<tr>
<td><strong>缓存补齐</strong></td>
<td style="text-align:center"><strong>3</strong></td>
<td><strong>1(规则1)</strong></td>
<td></td>
</tr>
<tr>
<td><strong>(int) b</strong></td>
<td style="text-align:center"><strong>4</strong></td>
<td><strong>4</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="三、包含共同体类型变量的内存对齐"><a href="#三、包含共同体类型变量的内存对齐" class="headerlink" title="三、包含共同体类型变量的内存对齐"></a>三、包含共同体类型变量的内存对齐</h2><pre><code>struct BU
{
    int number;             //4字节
    union UBffer
    {
        char buffer[13];    //填充3字节，该成员占16字节空间
        int number;
    }ubuf;
    int aa;                 //占4字节空间,当前偏移量已补齐为20
    double dou;             //占8字节空间
}bu;
</code></pre><p><code>sizeof(BU) = 4 + 13 + 3(补齐) + 4 + 8 = 32</code>，分析方法类似，在计算aa的偏移量时，我们可以肯定的是一定是int类型的整数倍，由于不作任何缓冲补齐的情况下，<code>number + buffer = 17</code>字节，为了符合规则1，需要填充3个字节。<br>结构体BU稍微变换下aa和dou成员顺序，结果将大不相同:</p>
<pre><code>struct BC
{
    int number;             //4字节
    union UBffer
    {
        char buffer[13];    //填充7字节，该成员占20字节空间
        int number;
    }ubuf;
    double dou;             //占8字节空间，当前偏移量已补齐为24
    int aa;                 //占4字节空间，当前占用空间36字节，最大double类型，还需要根据规则2补齐
}bc;
</code></pre><p>此时<code>sizeof(BC) = 4 + 13 + 7(规则1补齐) + 8 + 4 + 4(规则2补齐) = 40 (8的整数倍)</code></p>
<p>我们可能对于结构体类包含union类型成员抱有疑虑，再考虑下面实例：</p>
<pre><code>struct BD
{
    short number;
    union UBffer
    {
        char buffer[13];
        int number;
    }ubuf;
}bd;
</code></pre><p>运行结果是<code>sizeof(BD) = 2 + 2 + 13 +3 = 20</code>，可能你会问，为什么不是<code>2+13+1 = 16</code>，这是因为union类型比较特殊，计算union成员的偏移量时，需要根据union内部最大成员类型来进行缓冲补齐，所以为了保证偏移量为union最大成员int类型的整数倍，需要在number(short类型)后面填充2个字节，前面例子中number是int类型，就没有这个必要了。</p>
<p>再比如:</p>
<pre><code>struct BE
{
    short number;
    union UBffer
    {
        char buffer[13];
        double number;
    }ubuf;
}be;
</code></pre><p>它的运行结果是<code>sizeof(BE) = 2 + 6 + 13 + 3 = 24</code>，number后面为了与double类型进行对齐而补齐了6个字节，最后再按照规则2补齐了3个字节</p>
<p>考虑规则3:<br>举个例子，在<code>#pragma pack(1)</code>时，以1个字节对齐时，属于最简单的情况，结构体大小是所有成员的类型大小的和。所以<code>sizeof(BU) = sizeof(BC) = 29</code>,这时与成员变量顺序不再相关。其他指定的字节对齐也很好分析。一般而言，奇数个字节对齐没有意义，正常情况下，编码人员不关心编译器对内存对齐所作的工作。<br>上面的例子都想明白之后，内存对齐的规则应该了然于胸了。</p>
<p>PS: C语言中<code>offsetof()</code>函数可用于查看特定的结构体成员在结构体中的偏移量，编程时可以用于验证上面的说法。其实现类似如下:</p>
<pre><code>#define offsetof(type, member) (size_t)&amp;(((type *)0)-&gt;member)
</code></pre><p>原理是，强制将结构体(类型为type)的起始地址置为0，然后输出其成员的地址，该地址的大小就是成员在结构体中的偏移量。</p>
<h2 id="四、规则之外的例子"><a href="#四、规则之外的例子" class="headerlink" title="四、规则之外的例子"></a>四、规则之外的例子</h2><p>C99中定义了柔性数组机制，因此对于一个结构体，如果最后一个成员是数组的话，结构体大小与该成员是否是柔性数组有密切关系。</p>
<pre><code>struct sds{
    unsigned int len;
    unsigned int free;
    char buf[0];//或char buf[]
};
</code></pre><p>当结构体定义中，最后一个成员是数组且数组大小为0或没标记时，该成员数组是柔性数组，不计入结构体大小，因此<code>sizeof(sds) = 8</code><br>而下面的结构体sd的<code>sizeof(sd) = 12</code>，因为最后一个数组成员是普通数组，适用于上述补齐规则。</p>
<pre><code>struct sds{
    unsigned int len;
    unsigned int free;
    char buf[1];
};
</code></pre><p>我们知道，C++为了兼容C，保留了struct关键字，但是实际上C++中的struct是一个默认访问控制权限为public的class。C++标准规定:一个空类的大小为1个字节，因此在C++中，<code>sizeof(空类或空结构体) = 1</code>，在C语言中，<code>sizeof(空结构体) = 0</code>。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生活篇-进阶的厨房小生]]></title>
      <url>/2020/07/19/%E7%94%9F%E6%B4%BB%E7%AF%87-%E8%BF%9B%E9%98%B6%E7%9A%84%E5%8E%A8%E6%88%BF%E5%B0%8F%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>  <img src="/images/chef/cover-kitchen.jpg" alt="post-cover"></p>
<p>此篇博客备忘自己闲时制作的家常菜,记录生活。<br>第六章节是自己厨艺入门时看到网文并留下的笔记，供参考。<br>另,部分菜谱和操作流程参考自微信公众号:<strong>艾格吃饱了</strong></p>
<p>目录一览：</p>
<blockquote>
<ul>
<li>一、”盗版”的班尼迪克蛋</li>
<li>二、芦笋烩肥羊</li>
<li>三、糖醋排骨</li>
<li>四、西红柿鸡蛋+鸡腿乱炖</li>
<li>五、西红柿鸡蛋汤</li>
<li>六、厨艺入门讲解篇</li>
</ul>
<hr>
</blockquote>
<h2 id="一、”盗版”的班尼迪克蛋"><a href="#一、”盗版”的班尼迪克蛋" class="headerlink" title="一、”盗版”的班尼迪克蛋"></a>一、”盗版”的班尼迪克蛋</h2><h3 id="1-调制荷兰酱"><a href="#1-调制荷兰酱" class="headerlink" title="1.调制荷兰酱"></a>1.调制荷兰酱</h3><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>三个鸡蛋黄(最好是能生食的鸡蛋,推荐兰皇牌,色泽亮丽诱人)</li>
<li>半个柠檬(其实只用到几滴)</li>
<li>60克淡味黄油(60克查不多,实测还是别吃太油)</li>
<li>少许盐和黑胡椒</li>
</ul>
</blockquote>
<p><strong>step 1: 淡味黄油入锅小火融化,切记是小火,中大火容易将黄油烧焦;</strong><br><strong>step 2: 三个蛋黄放入适量大小的器皿,手打或打蛋器均可,打发至呈淡黄色，变得有些许粘稠;</strong><br><strong>step 3: 将融化的黄油分三次倒入蛋黄液中,一边倒入一边搅拌。不要停,混合均匀后再倒;</strong><br><strong>step 4: 最后用手指撒一小撮盐，少量胡椒粉，挤出适量柠檬汁继续混合均匀，柠檬汁可尝试后选择是否继续添加，搅拌到酱汁能均匀裹在勺子表面，就大功告成了。</strong></p>
<p><strong>如图：</strong><br>  <img src="/images/chef/6.jpg" style="width: 600px;"></p>
<p><strong><em>Tips：</em></strong><br><strong><em>① 荷兰酱的制作过程并不复杂，但容易失误。搅拌千万不要停，黄油不能有凝固</em></strong><br><strong><em>② 荷兰酱建议做好就吃掉</em></strong></p>
<h3 id="2-水波蛋"><a href="#2-水波蛋" class="headerlink" title="2.水波蛋"></a>2.水波蛋</h3><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>新鲜的鸡蛋(最好五天内产出的，本人用兰皇蛋制作效果非常好)</li>
</ul>
</blockquote>
<p><strong>step 1: 圆柱体形小锅装2/3锅水，用电磁炉烧开后转小火(煤气灶同理,不过本人未用煤气灶尝试);</strong><br><strong>step 2: 新鲜的鸡蛋敲开放入碗中;</strong><br><strong>step 3: 用一双筷子插入受小火,底部微微冒泡的那锅水中,顺时针搅动筷子形成漩涡;</strong><br><strong>step 4: 将打入碗中的鸡蛋轻轻滑入漩涡中;</strong><br><strong>step 5: 大概三分钟可以捞出,具体时间可根据家用电器多次尝试自行记录。</strong></p>
<p><strong>如图：</strong><br>  <img src="/images/chef/5.jpg" style="width: 600px;"></p>
<p>为什么要用新鲜鸡蛋？<br>因为新鲜鸡蛋的蛋清粘稠，能做出结实挺拔的水波蛋，放置时间久了的鸡蛋做出来会有很多絮状物，不漂亮。而且蛋白不易凝固，看起来非常松散。</p>
<h3 id="3-辅料与组装环节"><a href="#3-辅料与组装环节" class="headerlink" title="3.辅料与组装环节"></a>3.辅料与组装环节</h3><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>英式麦芬（本人用荞麦吐司代替）</li>
<li>培根（本人用大块火腿代替）</li>
</ul>
</blockquote>
<p><strong>step 1: 培根入锅,煎出油两面微卷,使用培根是因为自带油不用额外加;</strong><br><strong>step 2: 培根出锅,将麦芬倒扣在煎过培根有油的锅面,15秒左右接触锅的一面变焦黄,关火取出;</strong><br><strong>step 3: 装盘,底部麦芬,垫上培根,盖上水波蛋,淋上荷兰酱,撒一点海苔碎,完美出品。</strong></p>
<p><strong>如图：</strong><br>  <img src="/images/chef/4.jpg" style="width: 600px;"></p>
<h2 id="二、芦笋烩肥羊"><a href="#二、芦笋烩肥羊" class="headerlink" title="二、芦笋烩肥羊"></a>二、芦笋烩肥羊</h2><p><strong>准备材料:</strong></p>
<blockquote>
<ul>
<li>适量新鲜芦笋;</li>
<li>适量肥羊;</li>
</ul>
</blockquote>
<p><strong>step 1: 芦笋洗净去掉老的根茎部分,切段</strong><br><strong>step 2: 小锅烧水煮开,放入适量盐,橄榄油,倒入芦笋焯水,约3~5分钟,时长可自行把控,出水后立即将芦笋倒入凉水中或在水龙头底下冲洗,盛盘备用</strong><br><strong>step 3: 锅中剩下的水别浪费,放入肥牛15秒左右煮熟捞出，捞出也是冲凉水再盛盘备用</strong><br><strong>step 4: 开火热锅,倒入冷油,倒入焯水后的芦笋,翻炒10秒左右添加适量生抽、耗油，翻炒20秒倒入肥羊，添加适量鸡精、盐，继续翻炒1~2分钟出锅</strong></p>
<p><strong>如图：</strong><br>  <img src="/images/chef/2.jpg" style="width: 600px;"></p>
<p><strong><em>Tips：</em></strong><br><strong><em>① 芦笋焯水放入盐和橄榄油是给焯水后的芦笋提色</em></strong><br><strong><em>② 焯水后的食材一般都过凉水，否则影响口感</em></strong><br><strong><em>③ 调味品“适量”作何解释清参考第六章节</em></strong></p>
<h2 id="三、糖醋排骨"><a href="#三、糖醋排骨" class="headerlink" title="三、糖醋排骨"></a>三、糖醋排骨</h2><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>排骨</li>
<li>大葱、姜、八角</li>
<li>冰糖</li>
<li>小葱</li>
</ul>
</blockquote>
<p><strong>step 1: 小葱切成葱花状备用，排骨切小段冷水下锅加入料酒，煮出血沫</strong><br><strong>step 2: 排骨捞出过凉水尽量沥干，起油烧锅下入排骨，煎至八面金黄</strong><br><strong>step 3: 加入葱、姜、八角，再依次适量生抽、老抽、耗油、冰糖，最后添加一碗清水</strong><br><strong>step 4: 锅中沸腾加入适量盐和鸡精，转小火炖40分钟</strong><br><strong>step 5: 大火收汁撒下小葱花</strong></p>
<p><strong>如图：</strong><br>  <img src="/images/chef/3.jpg" style="width: 600px;"></p>
<p><strong><em>Tips：</em></strong><br><strong><em>排骨焯水时间不宜过长，出现血沫后1分钟出锅过凉，否则肉质很柴</em></strong></p>
<h2 id="四、西红柿鸡蛋-鸡腿乱炖"><a href="#四、西红柿鸡蛋-鸡腿乱炖" class="headerlink" title="四、西红柿鸡蛋+鸡腿乱炖"></a>四、西红柿鸡蛋+鸡腿乱炖</h2><h3 id="1-西红柿鸡蛋"><a href="#1-西红柿鸡蛋" class="headerlink" title="1.西红柿鸡蛋"></a>1.西红柿鸡蛋</h3><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>2个适量大小西红柿(不要挑选过熟的，避免炒起来汁水太多，影响蛋的香气。)</li>
<li>4~5个鸡蛋</li>
<li>番茄酱</li>
</ul>
</blockquote>
<p><strong>step 1: 蕃茄不去皮，对半切开去蒂，滚刀块切成差不多大小的三角块。特别要求切成三角块，是尽量把汁浆部分包裹在果肉里，以减少出汁。</strong><br><strong>step 2: 4-5个鸡蛋，加一调料勺盐和一点点料酒，用筷子挑散蛋液，把盐和酒搅拌均匀。不要勤力打蛋至出泡程度，但盐一定要搅匀。</strong><br><strong>step 3: 热锅冷油,油量大约占蛋液1/5或1/6体积,根据习惯用量,保持中小火，一层蛋液凝固后即拿勺子由边缘向中心推起，反复多次</strong><br><strong>step 4: 蛋液凝固后，划成小块，轻轻拨散翻面，始终保持中小火，煎炒到蛋块出香味，但注意蛋块仍然保持嫩度，不能炒老。凑近闻到蛋块香味后即出锅。</strong><br><strong>step 5: 原锅里加一小勺油，仍然保持中小火，下蕃茄酱一大勺（中式单人瓷勺），加3-4调料勺砂糖，炒至变色。</strong><br><strong>step 6: 下蕃茄块，中火翻炒，把蕃茄酱均匀裹在蕃茄块上。炒至八分熟即可，也即蕃茄皮微微皱起。</strong><br><strong>step 7: 这时锅里已经有不少蕃茄汁了，下蛋块，把蕃茄汁均匀裹在蛋块上。最后开大火收汁，出锅前手指撮一点点盐在锅里洒一圈。</strong></p>
<p><strong><em>Tips：</em></strong><br><strong><em>最后开大火的原因，一是为了把过多的汤汁收掉些，使炒蛋更香，二是为了使炒蛋上桌时足够热，令人更有食欲。</em></strong></p>
<h3 id="2-西红柿鸡蛋"><a href="#2-西红柿鸡蛋" class="headerlink" title="2.西红柿鸡蛋"></a>2.西红柿鸡蛋</h3><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>4~5个新鲜大鸡腿</li>
<li>大葱、姜、八角、干辣椒</li>
<li>少量包菜，洋葱</li>
<li>小葱</li>
</ul>
</blockquote>
<p><strong>step 1: 包菜切丝或撕成块、洋葱切弯条状、小葱切成葱花状备用；鸡腿切块冷水下锅加入料酒，煮出血沫</strong><br><strong>step 2: 鸡腿块捞出过凉水尽量沥干，起油烧锅下入排骨，煎至八面金黄</strong><br><strong>step 3: 加入葱、姜、八角、干辣椒，再依次添加适量黄豆酱、生抽、老抽、耗油、冰糖，最后添加半罐啤酒、一碗清水（黄豆酱、啤酒可根据喜好去除）</strong><br><strong>step 4: 锅中沸腾加入适量盐和鸡精，转小火炖10分钟</strong><br><strong>step 5: 加入切好的包菜、洋葱，小火再炖10分钟</strong><br><strong>step 5: 大火收汁撒下小葱花</strong></p>
<p><strong>如图：</strong><br>  <img src="/images/chef/1.jpg" style="width: 600px;"></p>
<h2 id="五、西红柿鸡蛋汤"><a href="#五、西红柿鸡蛋汤" class="headerlink" title="五、西红柿鸡蛋汤"></a>五、西红柿鸡蛋汤</h2><p><strong>准备材料：</strong></p>
<blockquote>
<ul>
<li>2个适量大小西红柿(不要挑选过熟的，避免炒起来汁水太多，影响蛋的香气。)</li>
<li>2个新鲜鸡蛋</li>
<li>适量小葱花</li>
</ul>
</blockquote>
<p><strong>step 1: 蕃茄不去皮，对半切开去蒂，滚刀块切成差不多大小的三角块。特别要求切成三角块，是尽量把汁浆部分包裹在果肉里，以减少出汁。</strong><br><strong>step 2: 炒锅大火烧热（微微地冒起了热气），下一瓷勺油，热锅冷油马上下蕃茄，轻轻用木勺翻炒，直到蕃茄微微起皮</strong><br><strong>step 3: 加入一碗多一点清水煮开，蕃茄皮会自然脱落，捞出。然后，必须在这时加入4克盐。换算成调料勺，平平一勺盐大约3克，再多加一点就是了</strong><br><strong>step 4: 确认你放完盐了，再开始打鸡蛋。两个鸡蛋轻轻用筷子搅散至匀，不用哗哗打,蛋花要嫩</strong><br><strong>step 5: 蕃茄汤煮滚，就下蛋花，顺时针搅,等水再滚开就马上关火。水滚其实不超过 10 秒，几乎打下去歇一会就能关火。</strong><br><strong>step 6: 出锅撒葱花(根据喜好来,不喜欢可以略过这一步)</strong></p>
<p>这样做出来的蛋汤，汤色清，蛋花嫩，合适的盐分刚好吊出蛋的鲜味来。而蕃茄呢，因为只是轻炒至刚熟，便仍然保留着微微清新的酸甜。<strong>如图:</strong><br>  <img src="/images/chef/7.jpg" style="width: 600px;"></p>
<p><strong><em>Tips:</em></strong><br><strong><em>① 注意加盐时机,如果蛋花下锅后再加盐,蛋花会变得稀碎,不美观</em></strong><br><strong><em>② 下蛋花时水还没烧滚，蛋花就不成形，也会碎</em></strong></p>
<h2 id="六、厨艺入门讲解篇"><a href="#六、厨艺入门讲解篇" class="headerlink" title="六、厨艺入门讲解篇"></a>六、厨艺入门讲解篇</h2><p><strong>对厨艺新手的名词解释和量化指标</strong></p>
<p>切菜的基本款：丝、柳、条、丁、块。<br>丝状宽约0.33cm 长约4cm 厚约0.3cm<br>柳、条、丁均宽约1cm 长约4cm 柳和条区别在于厚度，柳和丝状同厚0.3cm，条和丁同厚1cm<br>块，滚刀切块指下刀姿势不变，滚动食材约45°，适合长条型茄子和笋；番茄也可以斜着三角切，让蕃茄的种子和果肉均匀分布在一块上，炒起来不容易分离出水</p>
<p>猪肉、鸡肉要顺纹理切，否则肉丝容易断<br>牛肉要逆纹理切。<br>注:菜刀要锋利，新手会更容易切</p>
<p>肉丝上浆：依次放入盐小半调料勺、水2瓷勺、料酒1瓷勺、蛋清1个、淀粉1调料勺。<br>用手抓均，放置一会儿，让肉把水分吃进去。最后倒一层油，保鲜膜封好，放入冰箱腌制20分钟。油的作用是防止腌肉氧化出水。<br>注:调料勺指调料罐中的塑料勺，一平调料勺盐约3g；瓷勺指中式单人喝汤的勺，容量约15ml</p>
<p>焯水：去掉食物中不该有的气味<br>(1).大块的肉，要用冷水锅焯水，主要为了去除血腥气。把肉放进冷水锅，煮滚后再滚5分钟，直到血沫完全焯出，把肉捞出后冷水冲洗干净。<br>(2).菜谱上要求给蔬菜焯水，一般为了去掉青草气。水里放3调料勺盐，水滚后放入蔬菜，默数8秒即可。焯过水的蔬菜更容易熟，炒菜时也不吸油。</p>
<p>热锅冷油：开中火把锅子烧到很热，然后倒入大量油，再马上放入上过浆的肉丝温熟。<br>注1:入锅后先不要搅动，等油温上来，肉丝成形，再用筷子将肉丝划开轻轻搅动，肉丝变白浮起后捞出。<br>注2:热锅冷油，油量一般是锅子容量的1/4-1/3。炸东西，油量用到锅子容量的1/2。</p>
<p>蔬菜，一瓷勺油，油温7成热爆炒，炒青椒约莫2min</p>
<p>不同油温:<br>二成热：调成小火来炒酱料。<br>五成热：滑炒肉片。<br>七成热：爆香调料（也就是传说中的「炝锅」），爆炒蔬菜也是这个油温。<br>八成热：油炸或煎，鱼和肉外皮变得酥脆。</p>
<p>名词解释①：适量盐，是多少盐？<br>「适量」，就是放下去咸淡刚好，有了味道，但不过头。<br>这个可以根据自己的口味来确定。200g菜量，第一次先加1调料勺半盐，是我做菜的盐量。尝味后如果觉得不够，再半勺半勺加。<br>你的口味要自己试，试完，记住这个分量。以及，盐一般是出锅前加。<br>名词解释②：少许盐，是多少盐？<br>「少许」，是指一次加进去不会让味道太过头，多用来提鲜和增香。习惯最好以半勺为准，装在调料罐里的调料，用调料勺，比如半勺盐、半勺糖。<br>装在瓶子里的调料，用瓷勺：半勺生抽、半勺黄酒。<br>名词解释③：断生，不是让你了断人生<br>「断生」，说人话，就是炒熟。新手最简单的方法就是尝尝看。<br>有时候菜谱上让你把大块的肉「煮到断生」，可以用筷子戳戳看。一筷子进去，拔出来不带出血水，就是肉熟了。<br>名词解释④：爆香<br>经常看到菜谱上写，葱蒜姜爆香。这是给菜提香用的。<br>爆香，就是七成热油温，把葱姜蒜炒出香味。考官说，讲究点的，爆香后会把料都捞出，只留香喷喷的油。</p>
<p>中式一瓷勺液体均为15ml<br>老抽25g：约1.5瓷勺<br>生抽5g：约1/3瓷勺<br>白砂糖15g：约2瓷勺<br>料酒30g：约2瓷勺<br>生姜20g：大约5片<br>冰糖8g：两粒八角大小的冰糖<br>油30g：约2瓷勺<br>盐3g：约平平的一调料勺</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[函数指针和回调函数]]></title>
      <url>/2020/07/12/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>  <img src="/images/FunctionPointer/functionPointer.jpg" alt="post-cover"></p>
<p>参考链接1：<a href="https://blog.csdn.net/u010280075/article/details/88914424" target="_blank" rel="external">指针函数和函数指针-作者:chenyc4</a><br>参考链接2：<a href="https://www.jianshu.com/p/405a81d8e7b4" target="_blank" rel="external">C++函数指针详解-作者:羽裳有涯</a><br>参考链接3：<a href="https://www.zhihu.com/question/19801131/answer/17158216" target="_blank" rel="external">回调函数(callback)是什么-作者:no.bady</a></p>
<p>此篇博客是由日常学习、阅读，参考其他优秀博客总结而成，旨在通过文字结合实例的方式来理解回调函数。<br>目录一览：</p>
<blockquote>
<ul>
<li>指针函数与函数指针</li>
<li>函数指针应用实例-回调函数</li>
</ul>
</blockquote>
<hr>
<h2 id="一、指针函数与函数指针"><a href="#一、指针函数与函数指针" class="headerlink" title="一、指针函数与函数指针"></a>一、指针函数与函数指针</h2><p>首先明确这两个概念，指针函数中定语是“指针”，被修饰的名词是“函数”，所以，指针函数理解为返回指针类型的函数；相应地，函数指针理解为指向函数的指针。</p>
<h3 id="1-指针函数"><a href="#1-指针函数" class="headerlink" title="1.指针函数"></a>1.指针函数</h3><p>前面说到，指针函数本质上是函数，其返回值是指针类型，如下：</p>
<pre><code>ret* func(args, ...);
</code></pre><p>其中，<code>func</code>是一个函数，<code>args</code>是形参列表，<code>ret*</code>作为一个整体，是<code>func</code>函数的返回值，是一个指针的形式。</p>
<p><strong>此处不再做过多赘述，但值得注意的是，对于指针函数，在函数体内最终的返回值，一定是存放在堆中、跟随程序运行生命周期的静态变量或全局变量，因为若返回值是存放在栈中的局部变量，局部变量随时被系统回收，指针指向这个变量的内存地址随时被更改而导致不可预料的问题</strong></p>
<h3 id="2-函数指针"><a href="#2-函数指针" class="headerlink" title="2.函数指针"></a>2.函数指针</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><blockquote>
<ul>
<li>每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。</li>
</ul>
</blockquote>
<h4 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h4><blockquote>
<ul>
<li><code>指向函数的指针变量</code>的一般定义形式为：数据类型 (*指针变量名)(参数表);</li>
</ul>
</blockquote>
<h4 id="2-3-说明"><a href="#2-3-说明" class="headerlink" title="2.3 说明"></a>2.3 说明</h4><blockquote>
<ul>
<li>函数指针的定义形式中的<code>数据类型</code>是指<code>函数的返回值的类型</code></li>
<li>区分以下两个语句:<br>  int (<em>p)(int a, int b); //p是一个指向函数的指针变量，所指函数的返回值类型为整型<br>  int </em>p(int a, int b); //p是函数名，此函数的返回值类型为整型指针</li>
<li><code>指向函数的指针变量</code>不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的；在程序中把哪一个<code>函数的地址</code>赋给它，它就指向哪一个函数。</li>
<li>在给函数指针变量赋值时，只需给出函数名，而不必给出参数。<br>如函数max的原型为：int max(int x, int y);<br>指针p的定义为：int (*p)(int a, int b);<br>则p = max;的作用是将函数max的入口地址赋给指针变量p。这时，p就是指向函数max的指针变量，也就是p和max都指向函数的开头。</li>
<li>在一个程序中，<code>指针变量p</code>可以先后指向不同的函数，但一个函数不能赋给一个不一致的函数指针（<code>即不能让一个函数指针指向与其类型不一致的函数</code>）。<br>  如有如下的函数：int fn1(int x, int y); int fn2(int x);<br>  定义如下的函数指针：int (<em>p1)(int a, int b); int (</em>p2)(int a);<br>  则<br>  p1 = fn1; //正确<br>  p2 = fn2; //正确<br>  p1 = fn2; //产生编译错误</li>
<li>定义了一个<code>函数指针</code>并让它<code>指向</code>了一个<code>函数</code>后，对函数的<code>调用</code>可以通过<code>函数名调用</code>，也可以通过<code>函数指针调用</code>（即用指向函数的指针变量调用）。如语句：<code>c = (*p)(a, b);</code>//表示调用由p指向的函数(max)，实参为a,b，函数调用结束后得到的函数值赋给c。</li>
<li>函数指针只能指向函数的入口处，而不可能指向函数中间的某一条指令。不能用<code>*(p+1)</code>来表示函数的下一条指令。</li>
<li><code>函数指针变量</code>常用的用途之一是把指针作为<code>参数</code>传递到其他<code>函数</code>。</li>
</ul>
</blockquote>
<h4 id="2-4-举例"><a href="#2-4-举例" class="headerlink" title="2.4 举例"></a>2.4 举例</h4><p>源代码:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;conio.h&gt;

int max(int x, int y); //求最大数
int min(int x, int y); //求最小数
int add(int x, int y); //求和
void process(int i, int j, int (*p)(int a, int b)); //应用函数指针

int main()
{
    int x, y;
    cin&gt;&gt;x&gt;&gt;y;

    cout&lt;&lt;&quot;Max is: &quot;;
    process(x, y, max);

    cout&lt;&lt;&quot;Min is: &quot;;
    process(x, y, min);

    cout&lt;&lt;&quot;Add is: &quot;;
    process(x, y, add);

    getch();
    return 0;
}

int max(int x, int y)
{
    return x &gt; y ? x : y;
}

int min(int x, int y)
{
    return x &gt; y ? y : x;
}

int add(int x, int y)
{
    return x + y;
}

void process(int i, int j, int (*p)(int a, int b))
{
    cout&lt;&lt;p(i, j)&lt;&lt;endl;
}
</code></pre><p>输出结果：</p>
<pre><code>3 6
Max is: 6
Min is: 3
Add is: 9
</code></pre><h2 id="二、函数指针应用实例-回调"><a href="#二、函数指针应用实例-回调" class="headerlink" title="二、函数指针应用实例-回调"></a>二、函数指针应用实例-回调</h2><h3 id="1-什么是回调函数"><a href="#1-什么是回调函数" class="headerlink" title="1.什么是回调函数"></a>1.什么是回调函数</h3><p>我们绕点远路来回答这个问题。</p>
<p>编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写<code>库</code>；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是<code>应用</code>。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。</p>
<p>当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为<code>回调函数</code>（callback function）。</p>
<p>打个比方，有一家旅馆提供<strong><code>叫醒服务</code></strong>，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为<code>登记回调函数</code>（to register a callback function）。如下图所示（图片来源：维基百科）:</p>
<p>  <img src="/images/FunctionPointer/callBack.png" style="width: 800px;"></p>
<p>可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再<code>回</code>过头来<code>调</code>用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。</p>
<h3 id="2-回调机制的优势"><a href="#2-回调机制的优势" class="headerlink" title="2.回调机制的优势"></a>2.回调机制的优势</h3><p>从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为<code>中间函数</code>了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。</p>
<p>这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：</p>
<p><strong><em>even.py</em></strong></p>
<pre><code>#回调函数1
#生成一个2k形式的偶数
def double(x):
    return x * 2

#回调函数2
#生成一个4k形式的偶数
def quadruple(x):
    return x * 4
</code></pre><p><strong><em>callback_demo.py</em></strong></p>
<pre><code>from even import *

#中间函数
#接受一个生成偶数的函数作为参数
#返回一个奇数
def getOddNumber(k, getEvenNumber):
    return 1 + getEvenNumber(k)

#起始函数，这里是程序的主函数
def main():    
    k = 1
    #当需要生成一个2k+1形式的奇数时
    i = getOddNumber(k, double)
    print(i)
    #当需要一个4k+1形式的奇数时
    i = getOddNumber(k, quadruple)
    print(i)
    #当需要一个8k+1形式的奇数时
    i = getOddNumber(k, lambda x: x * 8)
    print(i)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><p>运行<code>callback_demp.py</code>，输出如下：</p>
<pre><code>3
5
9
</code></pre><p>上面的代码里，给<code>getOddNumber</code>传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。</p>
<h3 id="3-易被忽略的第三方"><a href="#3-易被忽略的第三方" class="headerlink" title="3.易被忽略的第三方"></a>3.易被忽略的第三方</h3><p>通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为<code>起始函数</code>（如上面的代码中注释所示）。</p>
<p>之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。</p>
<p>这里再做总结,对应实例中:<br><strong>起始函数:<code>main()</code></strong><br><strong>中间函数:<code>getOddNumber(k, getEvenNumber)</code></strong><br><strong>回调函数:<code>double(x)</code>、<code>quadruple(x)</code>、<code>lambda x: x * 8</code></strong></p>
<p>另外，回调实际上有两种：<code>阻塞式回调</code>和<code>延迟式回调</code>。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记某项目数据落地的交换机组网方式]]></title>
      <url>/2020/05/31/%E8%AE%B0%E6%9F%90%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E8%90%BD%E5%9C%B0%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%BB%84%E7%BD%91%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><img src="/images/Router/AccessInPoint.jpg" alt="post-cover"></p>
<p>此篇博客记录某国际项目中数据落地的交换机组网以及配置方式。<br>目录一览：</p>
<blockquote>
<ul>
<li>数据落地方案</li>
<li>Westermo交换机配置概要</li>
<li>to be defined</li>
</ul>
</blockquote>
<hr>
<h1 id="一、数据落地方案"><a href="#一、数据落地方案" class="headerlink" title="一、数据落地方案"></a>一、数据落地方案</h1><p><img src="/images/Router/solution.png" style="width: 800px;"></p>
<h2 id="1-Requirement-Analysis"><a href="#1-Requirement-Analysis" class="headerlink" title="1.Requirement Analysis"></a>1.Requirement Analysis</h2><p>① Three Network on the wayside: TVSS network in red, LTE network in blue and WIFI network in yellow;<br>② The data server in OCC implement 3 network interface cards connect to three network.<br>③ There are 5 train to ground channels:</p>
<blockquote>
<ul>
<li>Channel 1：Main line TVSS network，main line active path</li>
<li>Channel 2：Main line CG1-LTE1 network，main line backup path, Depot backup path</li>
<li>Channel 3：Main line CG2-LTE2 network，main line backup path, Depot backup path</li>
<li>Channel 4：Depot WIFI 1 network, depot active path</li>
<li>Channel 5：Depot WIFI 2 network, depot active path</li>
</ul>
</blockquote>
<p>④ When the train is running on the main line, channel 2 and channel 3 are available when channel 1 fails, and the loading will balanced with each other.<br>⑤ When the train arrive depot, channel 2 and channel 3 are available when channel 4 and channel 5 fail, and the loading will balanced with each other. </p>
<h2 id="2-Description-of-Solution"><a href="#2-Description-of-Solution" class="headerlink" title="2.Description of Solution"></a>2.Description of Solution</h2><p>On the main line: Automatic channel switching by Router</p>
<blockquote>
<ul>
<li>Install 2 L3 switches in MI carriages, and 4 L2 switches in the rest of carriages, build up a FRNT redundant ring.</li>
<li>Run VRRP on routers, Router 1 is the master router for first 3 carriages, Router 2 is the backup one. Router 2 is the master router for last 3 carriages, Router 1 is the backup one. Load balance design.</li>
<li>Channel 1(TVSS network in red) is main path for T2G communication, Channel 2 &amp; 3(CG-LTE1/2 network) is the secondary path. Device have multiple upstream Gateway with different priority. </li>
<li>end devices sent 3 frames with different destination address to red network,blue network and yellow network at same time, Router will select an available channel. when the red network is available, router will drop the two packets which destination address is not in red network.</li>
</ul>
</blockquote>
<p>In the depot: Automatic channel switching by CG box：</p>
<blockquote>
<ul>
<li>Channel switching between LTE and WiFi is done by CG box</li>
<li>end devices sent 2 frames with different destination address to yellow network and blue network at same time, CG box will select an available channel. Channel 4/5 (WIFI network) priority are higher than channel 2/3 (LTE network).</li>
</ul>
</blockquote>
<h1 id="二、Westermo交互机配置概要"><a href="#二、Westermo交互机配置概要" class="headerlink" title="二、Westermo交互机配置概要"></a>二、Westermo交互机配置概要</h1><h2 id="1-VLAN配置"><a href="#1-VLAN配置" class="headerlink" title="1.VLAN配置"></a>1.VLAN配置</h2><p>Web界面Configuration -&gt; VLAN -&gt; VLANs可以看到，交换机中存在一个默认 vlan 1；默认 vlan1 是包含所有端口的，即可通过所有端口进入该交换机。</p>
<p><img src="/images/Router/config1.png" style="width: 600px;"><br><img src="/images/Router/config2.png" style="width: 600px;"><br><img src="/images/Router/config3.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>VID:VLAN号，定义了VLAN特定身份</li>
<li>Name：VLAN名称，自动按照从vlan1 依次下推，改名为系统自动分配，web界面不能修改，可用console更改</li>
<li>Enabled：启动或禁用该 VLAN</li>
<li>Prio：VLAN 优先级设定，等级：0-7 或者禁用</li>
<li>IGMP：是否启用，打钩表示启用；不打勾表示未启用</li>
<li>Interface：规定隶属 VLAN 的端口；Tagged 表示带有标签（一般用于交换机之间<code>级联</code>）。<code>级联</code>举例：两个交换机上分别都有VLAN10和VLAN20，一般来说VLAN10互连、VLAN20互连需要占用2根网线和4个端口，打tag后，只需1根网线和2个端口，交互机根据tag自动区分数据包出口方向。</li>
</ul>
</blockquote>
<p>新建 Vlan 后，在交换机 Interface 会出现该新建的 Vlan。 点击：Configuration -&gt; Network -&gt; Interface，进入 Vlan IP 地址修改和管理。</p>
<p><img src="/images/Router/config4.png" style="width: 600px;"></p>
<h2 id="2-IP地址配置"><a href="#2-IP地址配置" class="headerlink" title="2.IP地址配置"></a>2.IP地址配置</h2><p>① 通过Web页面配置<br>Web界面Configuration -&gt; Network -&gt; Interface</p>
<p><img src="/images/Router/config5.png" style="width: 600px;"></p>
<p>进入到 IP 修改界面后，开始进行 IP 地址修改,点击Apply完成 IP 修改。</p>
<p><img src="/images/Router/config6.png" style="width: 600px;"></p>
<h2 id="3-FRNT配置"><a href="#3-FRNT配置" class="headerlink" title="3.FRNT配置"></a>3.FRNT配置</h2><p>环网结构:</p>
<p><img src="/images/Router/config7.png" style="width: 450px;"></p>
<p>每个环网只有一个 Focal Point，阻塞点位于 Focal Point 上。收敛时间&lt;20ms（200台交换机）<br>环网配置位于Web配置界面的Configuration L2Redundancy FRNT,点击 New新建一个 FRNT</p>
<p><img src="/images/Router/config8.png" style="width: 300px;"></p>
<blockquote>
<ul>
<li>Ring ID： FRNT 环网唯一标识符。目前只有一个 FRNT 环网</li>
<li>Focal Point：它是环网中代表拓扑结构改变的一个元素。如果你这是一个 Member(成员)，这里就不打勾</li>
</ul>
</blockquote>
<p>注意：一个 FRNT 只有一个 Focal Point，它会响应环网中拓扑结构变化，决定通讯链路及备援链路。其他环网成员就是默认的 Member（社员）。设置 member 时不要在 Focal Point 打勾。<br>Port M/Port N：FRNT需要分配两个端口作为环网端口。他们连接到相邻设备来组成 FRNT环。<br>然后点击 Apply完成配置</p>
<p><img src="/images/Router/config9.png" style="width: 300px;"></p>
<h2 id="4-VRRP配置"><a href="#4-VRRP配置" class="headerlink" title="4.VRRP配置"></a>4.VRRP配置</h2><p>VRRP: 多台路由器共享一个虚拟IP(VIP)地址,具有高优先级的路由器充当VIP主机,即Master,而其他路由器处于热备状态,即Backup</p>
<p><img src="/images/Router/config10.png" style="width: 450px;"></p>
<p>VRRP Group 同步,即R1两端同为主或备保持同步切换,不需要做链路检测或Track.westermo支持最多两组同步,如下图中VRID33和VRID1</p>
<p><img src="/images/Router/config11.png" style="width: 300px;"></p>
<p><strong>VRRP基本配置</strong><br>Web界面Configuration -&gt; Routing -&gt; VRRP,点击New进入VRRP配置</p>
<p><img src="/images/Router/config12.png" style="width: 450px;"><br><img src="/images/Router/config13.png" style="width: 450px;"></p>
<h2 id="5-CLI登录交换机"><a href="#5-CLI登录交换机" class="headerlink" title="5.CLI登录交换机"></a>5.CLI登录交换机</h2><p>需要console线或者网线通过putty软件用SSH方式登录</p>
<p><img src="/images/Router/config14.png" style="width: 450px;"></p>
<p>用console登陆，请检查Windows“设备管理器”中的“端口（COM和LPT）”获取COM端口信息。如下可以通过COM15进入交换机。</p>
<p><img src="/images/Router/config15.png" style="width: 450px;"><br><img src="/images/Router/config16.png" style="width: 450px;"></p>
<p>登陆帐号是admin</p>
<p><img src="/images/Router/config17.png" style="width: 600px;"></p>
<h2 id="6-默认网关配置"><a href="#6-默认网关配置" class="headerlink" title="6.默认网关配置"></a>6.默认网关配置</h2><p>为不同的VLAN配置不同的网关和distance,例:</p>
<p><img src="/images/Router/config18.png" style="width: 600px;"></p>
<p>通过show命令展示VLAN信息</p>
<p><img src="/images/Router/config19.png" style="width: 600px;"></p>
<h2 id="7-组播路由配置"><a href="#7-组播路由配置" class="headerlink" title="7.组播路由配置"></a>7.组播路由配置</h2><p>Web界面Configuration -&gt; Routing -&gt; Common,钩选Multicast启用组播路由，点击Apply完成</p>
<p><img src="/images/Router/config20.png" style="width: 450px;"></p>
<p>Static Route设置组播路由</p>
<p><img src="/images/Router/config21.png" style="width: 450px;"></p>
<p><strong>配置案例</strong></p>
<p>参照如下拓扑测试</p>
<p><img src="/images/Router/config22.png" style="width: 600px;"></p>
<p>Server 发组播流，Client 跨网段接收</p>
<p>① 启用组播路由并配置</p>
<p><img src="/images/Router/config23.png" style="width: 600px;"></p>
<p>② IGMP Snooping 启动<br>a) IGMP 必须启动，否则client 无法接收到组播流</p>
<p><img src="/images/Router/config24.png" style="width: 600px;"></p>
<p>③ IGMP fast leave ports 钩选<br>a)    默认端口Fast leave ports 不启用，Server正常发流，当Client退出组播组时，Client所连端口还会继续接收组播流直至组播监听timeout（default 300 sec）<br>b)    x10 端口Fast leave ports 钩选，Server正常发流，当Client退出组播组时，Client所连端口x10将快速切断组播流接收</p>
<p><img src="/images/Router/config25.png" style="width: 600px;"></p>
<p>④ Multicast router ports 启用<br>a)    Multicast router ports 针对所连end device或者Switch不具备IGMP功能。<br>b)    Multicast router ports 不启用，Server正常发流，当Client退出组播组时（如VLC关闭，停止接收视频流），Wireshark将抓不到UDP包。<br>c)    Multicast router ports 启用，Server正常发流，当Client退出组播组时（如VLC关闭，停止接收视频流），Wireshark依然能抓到UDP包。</p>
<p><strong><em>注意：以上测试设备—viper-212A-T3G，WeOS 4.27.0<br>当启用Multicast router ports功能，点击Apply，配置立即生效。<br>当取消Multicast router ports功能，点击Apply，配置无法立即生效，需将IGMP Snooping重新启用，即Disabled再Enabled。</em></strong></p>
<p><img src="/images/Router/config26.png" style="width: 600px;"></p>
<h2 id="8-端口镜像配置"><a href="#8-端口镜像配置" class="headerlink" title="8.端口镜像配置"></a>8.端口镜像配置</h2><p>通过端口镜像，可以对某个端口的流量进行监控</p>
<p><img src="/images/Router/config27.png" style="width: 600px;"><br><img src="/images/Router/config28.png" style="width: 600px;"></p>
<p>设置完成后，就可以将PC连接到设置好的端口(这里是X11)，通过Wireshark进行抓包</p>
<p><strong><em>注意:被设置了镜像的端口不能像正常端口一样使用,连接此端口的设备将ping不通其他端口,同Vlan下也ping不通</em></strong></p>
<h2 id="9-导出配置"><a href="#9-导出配置" class="headerlink" title="9.导出配置"></a>9.导出配置</h2><p>进入Maintenance -&gt; Backup &amp; restore</p>
<p><img src="/images/Router/config29.png" style="width: 600px;"></p>
<h2 id="10-导入配置"><a href="#10-导入配置" class="headerlink" title="10.导入配置"></a>10.导入配置</h2><p>① 进入Maintenance -&gt; Backup &amp; restore -&gt; Restore configuration 点击浏览</p>
<p><img src="/images/Router/config30.png" style="width: 600px;"></p>
<p>② 选择配置文件所在的位置</p>
<p><img src="/images/Router/config31.png" style="width: 600px;"></p>
<p>③ 点击Restore, 将配置导入即可</p>
<p><img src="/images/Router/config32.png" style="width: 600px;"></p>
<h1 id="三、to-be-defined"><a href="#三、to-be-defined" class="headerlink" title="三、to be defined"></a>三、to be defined</h1>]]></content>
      
        
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPN]]></title>
      <url>/2020/05/23/VPN/</url>
      <content type="html"><![CDATA[<p><img src="/images/VPS/VPN.jpg" alt="post-cover"></p>
<p>此篇文章共享自己搭建VPS生成的VPN账号,有心人可以尝试配置并看看墙外的世界。</p>
<p>tips:<br>①.流量有限，温柔点，别乱来；<br>②.IP若被封随时更改，有梯子需求的朋友可私信我获取。</p>
<hr>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><blockquote>
<ul>
<li>首先，联网并装了百度网盘的电脑</li>
<li>第二，好像没了…</li>
</ul>
</blockquote>
<h2 id="二、安装必要工具"><a href="#二、安装必要工具" class="headerlink" title="二、安装必要工具"></a>二、安装必要工具</h2><p>VPN软件PC版–<a href="https://pan.baidu.com/s/1X4u9Z7hJMLSUDgk8DrehDA" target="_blank" rel="external">解压缩运行即可</a><br>提取码:<code>as94</code></p>
<p>VPN软件Android版–<a href="https://pan.baidu.com/s/1N3th30ilZ0D-DjX8Zhvfnw" target="_blank" rel="external">解压缩发送到安卓手机安装</a><br>提取码:<code>nyxm</code></p>
<h2 id="三、配置信息"><a href="#三、配置信息" class="headerlink" title="三、配置信息"></a>三、配置信息</h2><p>①.运行PC版VPN软件后，看以下截图进行配置，点击“确认”：</p>
<p><img src="/images/VPS/123.png" style="width: 600px;"></p>
<p>②.代理模式也配置一下：</p>
<p><img src="/images/VPS/1234.png" style="width: 300px;"></p>
<p>③.配置就绪后点击链接–<a href="https://www.google.com/" target="_blank" rel="external">Google</a>。以后每次启动纸飞机就能访问外网了。</p>
<p>④.安卓手机安装好VPN软件后配置服务器地址、服务器端口、密码和加密方式就可以，这些信息上面截图都有。</p>
<p>⑤.有任何疑问请私信。</p>
<p>上面这些仅仅是客户端的配置，服务器那边也都是自己网上搜罗教程租用VPS来搭的，之前写过搭梯子博客教程但是被封，毕竟多多少少政治敏感，墙外的负面消息多，真假难辨。</p>
<hr>
<p><strong><em>最后</em></strong></p>
<p>技术无罪，共享精神无罪，但是，别干坏事，做个好人。</p>
<p><strong>当你凝视深渊时，深渊也在凝视你</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> 天梯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常识-人事档案相关]]></title>
      <url>/2020/05/05/%E5%B8%B8%E8%AF%86-%E4%BA%BA%E4%BA%8B%E6%A1%A3%E6%A1%88%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p><img src="/images/GeneralKnowledge/BackGround.png" alt="post-cover"></p>
<p>此篇博客内容整理自网络，主要介绍人事档案相关。<br>目录一览：</p>
<blockquote>
<ul>
<li>什么是人事档案</li>
<li>档案的作用</li>
<li>档案该怎么操作才能不当“弃档族”</li>
<li>档案成为“死档”的几种原因</li>
<li>档案不小心成为“死档”的处理方法</li>
</ul>
</blockquote>
<hr>
<h2 id="一、什么是人事档案"><a href="#一、什么是人事档案" class="headerlink" title="一、什么是人事档案"></a>一、什么是人事档案</h2><p>相信档案大多数人都没怎么重视过，因为人事档案大部分时间自己看不到，由相关部门进行托管。但是人事档案对于工作的人来说是计算工龄的一个重要凭证。其具体定义请参考–<a href="https://baike.baidu.com/item/%E4%BA%BA%E4%BA%8B%E6%A1%A3%E6%A1%88/5046345?fr=aladdin" target="_blank" rel="external">人事档案</a>。这里不再赘述。</p>
<h2 id="二、档案的作用"><a href="#二、档案的作用" class="headerlink" title="二、档案的作用"></a>二、档案的作用</h2><blockquote>
<ul>
<li>转正定级，获取干部身份。必须在第一家单位就业工作满一年，申请转正定级，才会获得干部身份了。干部身份有什么用，请参考–<a href="https://baike.baidu.com/item/%E5%B9%B2%E9%83%A8%E8%BA%AB%E4%BB%BD" target="_blank" rel="external">干部身份</a>；</li>
<li>考研；</li>
<li>考公务员，没有人事档案，没有办法过政审这关；</li>
<li>评职称，如果没有档案，你就没有干部身份，也就没有资格评职称。而职称往往是和工资和户口积分挂钩的。有职称，也是求职的一个砝码！</li>
<li>考资格证，比如会计专业资格考试等，考试需要和人事档案的地点相同，没有人事档案，你报名都可能报不上。</li>
<li>办理准生证，都需要男方存档案的地方开婚育证明；</li>
<li>出国审查，没有档案，政审就无法进行；</li>
<li>养老保险。工龄计算，必须要档案！退休后要拿到退休金，必须要档案，档案是否完备，也将影响到退休金的高低（根据2010年出台的相关文件，自2011年1月1日起，无档案人员也可以以养老保险实际缴纳年限来办理退休手续，但办理过程非常麻烦）；</li>
<li>某些大城市，比如上海，办理居住证，前提是将档案调到上海。没有档案，就没有办法办理居住证，也就没有办法落户上海了；</li>
<li>进国企，事业单位需要档案，而且这是一个非常重要的材料。如果你没有档案且不及时补救，那么这种好单位的大门也会向你关上；</li>
<li>住房补贴发放；</li>
<li>入团入党。</li>
</ul>
</blockquote>
<p>如果档案成为“死档”，以上事件办理将会很麻烦。</p>
<h2 id="三、档案该怎么操作才能不当“弃档族”"><a href="#三、档案该怎么操作才能不当“弃档族”" class="headerlink" title="三、档案该怎么操作才能不当“弃档族”"></a>三、档案该怎么操作才能不当“弃档族”</h2><p>1.毕业后档案不能放在自己手里。可以存放学校、生源地人事局、人才市场、劳动局，街道办事处，职业中介。</p>
<p>2.毕业后自己的第一份工作，如果档案转到单位或当地人才中心，一定要记得干满一年，然后向单位或人才申请转正定级，获得干部身份。</p>
<p>下面结合毕业生的各种情况，谈谈档案的处理方式：</p>
<blockquote>
<ul>
<li>毕业后档案存放学校（注意2年期限）：如果毕业后没有及时找到合适工作（或考研），导致毕业即失业，可以到学校申请暂缓就业，在两年内找到工作的，一定要及时回校办理档案转移，到学校将户籍和档案迁至工作单位所在地或单位所在地的人才市场。两年过后，学校就会打回原籍，很可能造成档案丢失。</li>
<li>毕业后档案存放人才市场（建议）：1)毕业没有找到单位的（或考研），可以去学校或单位所在的人才市场进行档案挂靠，千万不能弃档。人才市场都是人事局办的，是官方机构，这是政府部门，拥有档案保管权，有权办理转正定级，放在那里起码有安全保障。但要提醒的是， 一旦找到工作要及时办理就业手续，以便能够及时的进行转正定级，方便后面的正式调动。如果没有找到工作，也要记得人才交流中心的集体户口是属于临时户口，有两年的限期，毕业超过两年就不能继续托管了，会变成“死档”。一定要记得去处理。可以自己申请打回原籍，以免档案丢失。2)毕业后找到单位的，可放心的找就业地方人才市场挂靠，而且挂靠的人才市场可能会接收个人手上的档案。从存放在人才市场之日开始，就可以算我们的工龄了。就算以后到别的地方发展，也可以通过发调档函，很方便的转到新就业地人才市场。这样既不影响在当地工作，也不影响职称‘晋级’，工龄还能连续计算，顺畅地完成衔接。这里有个注意点是找到的第一份单位工作如果未做满一年，无法请求人才市场进行转正定级，将会失去干部身份。所以如果我们一定要离职，也一定要等到我们的第一份工作做满一年已经申请转正定级获得干部身份后。3)毕业后找到单位后又辞职到其他地方去的，这里还有个注意点：某些地方的人才市场5年内如果没有交档案保管费，人才市场保管档案的义务就会自动解除，档案会被封存，我们的档案会成为“死档”（35岁之前可以档案激活，35岁之后，就麻烦了）！</li>
<li>毕业后档案主动打回原籍（建议）：不管是否参加工作，都可将自己的档案拿回到原籍人事局或人才市场，省的以后麻烦，毕竟以后如果有事情可以让父母帮着处理。把档案放在家乡的人才市场，以后在外地找到工作后不会麻烦,一方面工作又不需要档案，就算是是找到国企、考到公务员，单位发函到你家乡人才市场调档案就可以了。</li>
<li>毕业后档案寄送公司/单位（不太建议）：现在一般公司都是把员工档案统一放在公司所在区的人才市场的。建议档案还是不要归公司管理，以防自己离职的时候档案很有可能被公司扣留。</li>
<li>档案存放在街道办事处（尽量不要）：档案在街道的话，一旦有单位录用你需要调取档案的话比较的麻烦。而且档案放在街道一样要交存档费用。</li>
</ul>
</blockquote>
<h2 id="四、档案成为“死档”的几种原因"><a href="#四、档案成为“死档”的几种原因" class="headerlink" title="四、档案成为“死档”的几种原因"></a>四、档案成为“死档”的几种原因</h2><blockquote>
<ul>
<li>档案丢失会成为“死档”。毕业生择业期为两年，因此择业期间可申请学校代管两年。放在学校两年期满后仍未落实工作的（或找到工作未及时来学校处理的），学校就会将档案和户口一起打回原籍了（或转到学生户口所在地的人才交流中心，或转至生源地所在地级市的人事局或教育局接收）。这里需要强调的是，在打回的过程中很容易把档案搞丢。所以要么两年内去落实工作，要么自己去办理户口和档案转移到某个人才市场或转移到家里去。很多人成为弃档族，就是这里搞丢了！</li>
<li>档案长期在自己手里超过2年，也会成为“死档”。</li>
<li>五年内没有交档案保管费而被人才市场等机构封存的，也会被认为是“死档”。</li>
</ul>
</blockquote>
<h2 id="五、档案不小心成为“死档”的处理方法"><a href="#五、档案不小心成为“死档”的处理方法" class="headerlink" title="五、档案不小心成为“死档”的处理方法"></a>五、档案不小心成为“死档”的处理方法</h2><blockquote>
<ul>
<li>毕业生择业期为两年，如档案遗失，造成没有有按规定办理存档手续而成为“死档”，毕业后未超过2年择业期的（有的地方是3年择业期），可直接去人才市场补办存档手续。超过了择业期，则可以按照非普通高等院校毕业生身份，携带身份证、学历证、户口簿等材料重新办理存档！但前提是不要超过35岁！</li>
<li>把档案留在人才服务机构超过5年没有理会的，只需要补齐代管费、办妥相关手续，就可将档案关系理顺。</li>
<li>自己携带档案要尽快向人才服务机构咨询，如果档案袋被打开，里面的资料需要经过相关部门核实，如果档案资料遗失，还要到原单位去补充和确认。</li>
<li>“跳槽”人员将档案遗留在原单位长期未办理转档手续的，要与原单位协商，解决跳槽后的遗留问题，以便及时将档案转交。</li>
</ul>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 常识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图解TCP/IP三次握手和四次挥手]]></title>
      <url>/2020/05/04/%E5%9B%BE%E8%A7%A3TCP-IP/</url>
      <content type="html"><![CDATA[<p>  <img src="/images/TCP-IP/001Background.jpg" alt="post-cover"><br>参考链接：<a href="https://mp.weixin.qq.com/s/pqUFksNEwT9UWDpcKdGpQg" target="_blank" rel="external">Python开发者公众号-小林coding</a></p>
<hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>不管面试 Java 、C/C++、Python 等开发岗位，TCP的知识点可以说是的必问的了。TCP虐我千百遍，我待TCP如初恋。</p>
<p>本文整理了关于TCP三次握手和四次挥手的面试题型，跟大家一起探讨探讨。</p>
<p><strong>0x00 TCP基本认识</strong></p>
<p>  <img src="/images/TCP-IP/002.png" style="width: 600px;"></p>
<p><strong>0x01 TCP连接建立</strong></p>
<p>  <img src="/images/TCP-IP/003.png" style="width: 600px;"></p>
<p><strong>0x02 TCP连接断开</strong></p>
<p>  <img src="/images/TCP-IP/004.png" style="width: 600px;"></p>
<p><strong>0x03 Socket编程</strong></p>
<p>  <img src="/images/TCP-IP/005.png" style="width: 600px;"></p>
<h2 id="二、TCP基本认识"><a href="#二、TCP基本认识" class="headerlink" title="二、TCP基本认识"></a>二、TCP基本认识</h2><h3 id="瞧瞧TCP头格式"><a href="#瞧瞧TCP头格式" class="headerlink" title="瞧瞧TCP头格式"></a>瞧瞧TCP头格式</h3><p>我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</p>
<p>  <img src="/images/TCP-IP/006.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>序列号:在建立连接时由计算机生成的随机数作为其初始值，通过<code>SYN</code>包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</li>
<li>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题</li>
<li>ACK：该位为1时，「确认应答」的字段变为有效，TCP规定除了最初建立连接时的<code>SYN</code>包之外该位必须设置为1。</li>
<li>RST：该位为1时，表示TCP连接中出现异常必须强制断开连接。</li>
<li>SYC：该位为1时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li>FIN：该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换<code>FIN</code>位置为1的TCP段。</li>
</ul>
</blockquote>
<h3 id="为什么需要TCP协议-TCP工作在哪一层"><a href="#为什么需要TCP协议-TCP工作在哪一层" class="headerlink" title="为什么需要TCP协议?TCP工作在哪一层?"></a>为什么需要TCP协议?TCP工作在哪一层?</h3><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p>  <img src="/images/TCP-IP/007.png" style="width: 400px;"></p>
<p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p>
<h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>  <img src="/images/TCP-IP/008.png" style="width: 300px;"></p>
<blockquote>
<ul>
<li>面向连接：一定是「一对一」才能连接，不能像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li>字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
</blockquote>
<h3 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h3><p>我们来看看<code>RFC 793</code>是如何定义「连接」的：</p>
<blockquote>
<ul>
<li>Connections:<br>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.<br>The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</li>
</ul>
</blockquote>
<p>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为<strong>连接</strong>。</p>
<p>  <img src="/images/TCP-IP/009.png" style="width: 200px;"></p>
<p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p>
<blockquote>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
</blockquote>
<h3 id="如何唯一确定一个TCP连接呢"><a href="#如何唯一确定一个TCP连接呢" class="headerlink" title="如何唯一确定一个TCP连接呢?"></a>如何唯一确定一个TCP连接呢?</h3><p>TCP四元组可以唯一的确定一个连接，四元组包括如下：</p>
<blockquote>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
</blockquote>
<p>  <img src="/images/TCP-IP/010.png" style="width: 500px;"></p>
<p>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过IP协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉TCP协议应该把报文发给哪个进程。</p>
<h3 id="有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？"><a href="#有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？" class="headerlink" title="有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？"></a>有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？</h3><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端IP和端口是可变的，其理论值计算公式如下:</p>
<p>对IPv4，客户端的IP数最多为2^32(IPv4地址理论数量)，客户端的端口数最多为2^16(计算机端口数最大为65535)，也就是服务端单机最大TCP连接数，约为2^48个。</p>
<p>当然，服务端最大并发TCP连接数远不能达到理论上限。</p>
<blockquote>
<ul>
<li>首先主要是文件描述符限制，Socket都是文件，所以首先要通过<code>ulimit</code> 配置文件描述符的数目；</li>
<li>另一个是内存限制，每个TCP连接都要占用一定内存，操作系统内存是有限的。</li>
</ul>
</blockquote>
<h3 id="UDP和TCP有什么区别呢-分别的应用场景是"><a href="#UDP和TCP有什么区别呢-分别的应用场景是" class="headerlink" title="UDP和TCP有什么区别呢?分别的应用场景是?"></a>UDP和TCP有什么区别呢?分别的应用场景是?</h3><p>UDP不提供复杂的控制机制，利用IP提供面向「无连接」的通信服务。</p>
<p>UDP协议真的非常简单，头部只有8个字节(64位)，UDP的头部格式如下：</p>
<p>  <img src="/images/TCP-IP/011.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>
<li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
</blockquote>
<p>TCP和UDP区别：<br>1.连接</p>
<blockquote>
<ul>
<li>TCP是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP不需要建立连接，即刻传输数据。</li>
</ul>
</blockquote>
<p>2.服务对象</p>
<blockquote>
<ul>
<li>TCP是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP支持一对一、一对多、多对多的交互通信。</li>
</ul>
</blockquote>
<p>3.可靠性</p>
<blockquote>
<ul>
<li>TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
</blockquote>
<p>4.拥塞控制、流量控制</p>
<blockquote>
<ul>
<li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率。</li>
</ul>
</blockquote>
<p>5.首部开销</p>
<blockquote>
<ul>
<li>TCP首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是<strong>20</strong>个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP首部只有<strong>8</strong>个字节，并且是固定不变的，开销较小。</li>
</ul>
</blockquote>
<p>TCP和UDP应用场景：</p>
<p>由于TCP是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<blockquote>
<ul>
<li>FTP文件传输</li>
<li>HTTP/HTTPS</li>
</ul>
</blockquote>
<p>由于UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<blockquote>
<ul>
<li>包总量较少的通信，如DNS、SNMP等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
</blockquote>
<h3 id="为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？"><a href="#为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？" class="headerlink" title="为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？"></a>为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？</h3><p>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。</p>
<h3 id="为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？"><a href="#为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？" class="headerlink" title="为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？"></a>为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？</h3><p>先说说 TCP 是如何计算负载数据长度：</p>
<p>  <img src="/images/TCP-IP/012.png" style="width: 600px;"></p>
<p>其中IP总长度和IP首部长度，在IP首部格式是已知的。TCP首部长度，则是在 TCP首部格式已知的，所以就可以求得TCP数据的长度。</p>
<p>大家这时就奇怪了问：“UDP也是基于IP层的呀，那UDP的数据长度也可以通过这个公式计算呀？为何还要有「包长度」呢？”</p>
<p>这么一问，确实感觉 UDP「包长度」是冗余的。因为为了网络设备硬件设计和处理方便，首部长度需要是<strong>4</strong>字节的整数倍。</p>
<p>如果去掉UDP「包长度」字段，那UDP首部长度就不是<strong>4</strong>字节的整数倍了，所以补充「包长度」字段很可能是为了补全UDP首部长度是<strong>4</strong>字节的整数倍。</p>
<h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><h3 id="TCP三次握手过程和状态变迁"><a href="#TCP三次握手过程和状态变迁" class="headerlink" title="TCP三次握手过程和状态变迁"></a>TCP三次握手过程和状态变迁</h3><p>TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接是通过三次握手而进行的。下图表示TCP三次握手流程:</p>
<p>  <img src="/images/TCP-IP/013.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>一开始，客户端和服务端都处于<code>CLOSED</code>状态。先是服务端主动监听某个端口，处于<code>LISTEN</code>状态。</li>
</ul>
</blockquote>
<p>客户端主动建立连接时发送的第一个报文—<code>SYN报文</code>:</p>
<p>  <img src="/images/TCP-IP/014.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端会随机初始化序号（client_isn），将此序号置于TCP首部的「序号」字段中，同时把<code>SYN</code>标志位置为<strong>1</strong>，表示<code>SYN</code>报文。接着把第一个<code>SYN</code>报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SENT</code>状态。</li>
</ul>
</blockquote>
<p>服务端收到请求后反馈的报文，即三次握手的第二个报文—<code>SYN+ACK报文</code>：</p>
<p>  <img src="/images/TCP-IP/015.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>服务端收到客户端的<code>SYN</code>报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入TCP首部的「序号」字段中，其次把TCP首部的「确认应答号」字段填入client_isn + 1, 接着把<code>SYN</code>和<code>ACK</code>标志位置为 <strong>1</strong>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code>状态。</li>
</ul>
</blockquote>
<p>客户端收到响应后发送的报文，即三次握手的第三个报文—<code>ACK报文</code>:</p>
<p>  <img src="/images/TCP-IP/016.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部<code>ACK</code>标志位置为<strong>1</strong>，其次「确认应答号」字段填入server_isn + 1，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于<code>ESTABLISHED</code>状态。</li>
<li>服务器收到客户端的应答报文后，也进入<code>ESTABLISHED</code>状态。</li>
</ul>
</blockquote>
<p>从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。</p>
<p>一旦完成三次握手，双方都处于<code>ESTABLISHED</code>状态，至此连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h3 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。</p>
<p>  <img src="/images/TCP-IP/017.png" style="width: 800px;"></p>
<h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p>
<p>在前面我们知道了什么是TCP连接：</p>
<blockquote>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</li>
</ul>
</blockquote>
<p>所以，重要的是为什么三次握手才可以初始化Socket、序列号和窗口大小并建立TCP连接。</p>
<p>接下来以三个方面分析三次握手的原因：</p>
<blockquote>
<ul>
<li>三次握手才可以阻止历史重复连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
</blockquote>
<p><strong><em>原因一：避免历史连接</em></strong></p>
<p>我们来看看<code>RFC 793</code>指出的TCP连接使用三次握手的首要原因：</p>
<blockquote>
<ul>
<li>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</li>
</ul>
</blockquote>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下TCP三次握手是如何避免的呢？</p>
<p>  <img src="/images/TCP-IP/018.png" style="width: 600px;"></p>
<p>客户端连续发送多次<code>SYN</code>建立连接的报文，在网络拥堵等情况下：</p>
<blockquote>
<ul>
<li>一个「旧<code>SYN</code>报文」比「最新的<code>SYN</code>」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个SYN + ACK报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送<code>RST</code>报文给服务端，表示中止这一次连接。</li>
</ul>
</blockquote>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<blockquote>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是<code>RST</code>报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报文是<code>ACK</code>报文，通信双方就会成功建立连接；</li>
</ul>
</blockquote>
<p>所以，TCP使用三次握手建立连接的最主要原因是防止历史连接初始化了连接。</p>
<p><strong><em>原因二：同步双方初始序列号</em></strong></p>
<p>TCP协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p>
<blockquote>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
</blockquote>
<p>可见，序列号在TCP连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的<code>SYN</code>报文的时候，需要服务端回一个<code>ACK</code>应答报文，表示客户端的<code>SYN</code>报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p>
<p>  <img src="/images/TCP-IP/019.png" style="width: 600px;"></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><strong><em>原因三：避免资源浪费</em></strong></p>
<p>如果只有「两次握手」，当客户端的<code>SYN</code>请求连接在网络中阻塞，客户端没有接收到<code>ACK</code>报文，就会重新发送<code>SYN</code>，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的<code>ACK</code>确认信号，所以每收到一个<code>SYN</code>就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的<code>SYN</code>阻塞了，重复发送多次<code>SYN</code>报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<p>  <img src="/images/TCP-IP/020.png" style="width: 600px;"></p>
<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求<code>SYN</code>报文，而造成重复分配资源。</p>
<p><strong>小结</strong></p>
<p>TCP建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<blockquote>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
</blockquote>
<h3 id="为什么客户端和服务端的初始序列号-ISN-是不相同的？"><a href="#为什么客户端和服务端的初始序列号-ISN-是不相同的？" class="headerlink" title="为什么客户端和服务端的初始序列号 ISN 是不相同的？"></a>为什么客户端和服务端的初始序列号 ISN 是不相同的？</h3><p>因为网络中的报文会延迟、会复制重发、也有可能丢失，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p>
<h3 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h3><p>起始<code>ISN</code>是基于时钟的，每<strong>4</strong>毫秒 + 1，转一圈要<strong>4.55</strong>个小时。</p>
<p><code>RFC 1948</code>中提出了一个较好的初始化序列号<code>ISN</code>随机生成算法。</p>
<p><strong>ISN = M + F (localhost, localport, remotehost, remoteport)</strong></p>
<blockquote>
<ul>
<li>M是一个计时器，这个计时器每隔<strong>4</strong>毫秒加 1。</li>
<li>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证Hash算法不能被外部轻易推算得出，用MD5算法是一个比较好的选择。</li>
</ul>
</blockquote>
<h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>我们先来认识下<code>MTU</code>和<code>MSS</code>:</p>
<p>  <img src="/images/TCP-IP/021.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>MTU：一个网络包的最大长度，以太网中一般为<strong>1500</strong>字节；</li>
<li>MSS：除去IP 和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度；</li>
</ul>
</blockquote>
<p>如果TCP的整个报文（头部 + 数据）交给IP层进行分片，会有什么异常呢？</p>
<p>当IP层有一个超过MTU大小的数据（TCP 头部 + TCP 数据）要发送，那么IP层就要进行分片，把数据分片成若干片，保证每一个分片都小于<code>MTU</code>。把一份IP数据报进行分片以后，由目标主机的IP层来进行重新组装后，在交给上一层 TCP传输层。</p>
<p>这看起来井然有序，但这存在隐患的，那么当如果一个IP分片丢失，整个IP报文的所有分片都得重传。</p>
<p>因为IP层本身没有超时重传机制，它由传输层的TCP来负责超时和重传。</p>
<p>当接收方发现TCP报文（头部 + 数据）的某一片丢失后，则不会响应<code>ACK</code>给对方，那么发送方的TCP在超时后，就会重发「整个TCP报文（头部 + 数据）」。</p>
<p>因此，可以得知由IP层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的 <code>MSS</code>值，当TCP层发现数据超过<code>MSS</code>时，则就先会进行分片，当然由它形成的IP包的长度也就不会大于<code>MTU</code>，自然也就不用IP分片了。</p>
<p>握手协商<code>MSS</code>:</p>
<p>  <img src="/images/TCP-IP/022.png" style="width: 600px;"></p>
<p>经过TCP层分片后，如果一个TCP分片丢失后，进行重发时也是以<code>MSS</code>为单位，而不用重传所有的分片，大大增加了重传的效率。</p>
<h3 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p><strong>SYN攻击</strong>:我们都知道TCP连接建立是需要三次握手，假设攻击者短时间伪造不同 IP地址的<code>SYN</code>报文，服务端每接收到一个<code>SYN</code>报文，就进入<code>SYN_RCVD</code>状态，但服务端发送出去的ACK + SYN报文，无法得到未知IP主机的<code>ACK</code>应答，久而久之就会占满服务端的SYN接收队列（未连接队列），使得服务器不能为正常用户服务。</p>
<p>  <img src="/images/TCP-IP/023.jpg" style="width: 600px;"></p>
<p><strong>避免 SYN 攻击方式一</strong>:</p>
<p>其中一种解决方式是通过修改Linux内核参数，控制队列大小和当队列满时应做什么处理。</p>
<blockquote>
<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li>
</ul>
</blockquote>
<pre><code>net.core.netdev_max_backlog
</code></pre><blockquote>
<ul>
<li>SYN_RCVD 状态连接的最大个数：</li>
</ul>
</blockquote>
<pre><code>net.ipv4.tcp_max_syn_backlog
</code></pre><blockquote>
<ul>
<li>超出处理能时，对新的<code>SYN</code>直接回<code>RST</code>，丢弃连接：</li>
</ul>
</blockquote>
<pre><code>net.ipv4.tcp_abort_on_overflow
</code></pre><p><strong>避免 SYN 攻击方式二</strong>:</p>
<p>我们先来看下Linux 内核的SYN（未完成连接建立）队列与Accpet（已完成连接建立）队列是如何工作的？</p>
<p>  <img src="/images/TCP-IP/024.png" style="width: 600px;"></p>
<p>正常流程：</p>
<blockquote>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li>
<li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
</blockquote>
<p>  <img src="/images/TCP-IP/025.png" style="width: 600px;"></p>
<p>应用程序过慢：</p>
<blockquote>
<ul>
<li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li>
</ul>
</blockquote>
<p>  <img src="/images/TCP-IP/026.png" style="width: 600px;"></p>
<p>受到 SYN 攻击：</p>
<blockquote>
<ul>
<li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</li>
</ul>
</blockquote>
<p>tcp_syncookies 的方式可以应对 SYN 攻击的方法：</p>
<pre><code>net.ipv4.tcp_syncookies = 1
</code></pre><p>  <img src="/images/TCP-IP/027.png" style="width: 600px;"></p>
<p>tcp_syncookies 应对 SYN 攻击</p>
<blockquote>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li>
<li>计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端；</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」；</li>
<li>最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
</blockquote>
<h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h2><h3 id="TCP四次挥手过程和状态变迁"><a href="#TCP四次挥手过程和状态变迁" class="headerlink" title="TCP四次挥手过程和状态变迁"></a>TCP四次挥手过程和状态变迁</h3><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过四次挥手方式。双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<p>  <img src="/images/TCP-IP/028.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端打算关闭连接，此时会发送一个TCP首部<code>FIN</code>标志位被置为<strong>1</strong>的报文，也即<code>FIN</code>报文，之后客户端进入<code>FIN_WAIT_1</code>状态。</li>
<li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入 <code>CLOSED_WAIT</code>状态。</li>
<li>客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li>
<li>等待服务端处理完数据后，也向客户端发送<code>FIN</code>报文，之后服务端进入<code>LAST_ACK</code>状态。</li>
<li>客户端收到服务端的<code>FIN</code>报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态</li>
<li>服务器收到了<code>ACK</code>应答报文后，就进入了<code>CLOSE</code>状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过<strong>2MSL</strong>一段时间后，自动进入<code>CLOSE</code>状态，至此客户端也完成连接的关闭。</li>
</ul>
</blockquote>
<p>你可以看到，每个方向都需要一个<code>FIN</code>和一个<code>ACK</code>，因此通常被称为四次挥手。这里一点需要注意是：主动关闭连接的，才有<code>TIME_WAIT</code>状态。</p>
<h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发<code>FIN</code>包的过程，就能理解为什么需要四次了。</p>
<blockquote>
<ul>
<li>关闭连接时，客户端向服务端发送<code>FIN</code>时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li>
</ul>
</blockquote>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p>
<h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><strong>MSL</strong>是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，而IP头中有一个TTL字段，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减<strong>1</strong>，当此值为<strong>0</strong>则数据报将被丢弃，同时发送ICMP报文通知源主机。</p>
<p>MSL与TTL的区别：MSL的单位是时间，而TTL是经过路由跳数。所以MSL应该要大于等于TTL消耗为0的时间，以确保报文已被自然消亡。</p>
<p><code>TIME_WAIT</code>等待2倍的MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的<code>ACK</code>报文，就会触发超时重发<code>Fin</code>报文，另一方接收到<code>FIN</code>后，会重发<code>ACK</code>给被动关闭方，一来一去正好2个MSL。</p>
<p>2MSL的时间是从客户端接收到<code>FIN</code>后发送<code>ACK</code>开始计时的。如果在<code>TIME-WAIT</code>时间内，因为客户端的<code>ACK</code>没有传输到服务端，客户端又接收到了服务端重发的<code>FIN</code>报文，那么2MSL时间将重新计时。</p>
<p>在Linux系统里2MSL默认是<strong>60</strong>秒，那么一个MSL也就是30秒。Linux系统停留在<code>TIME_WAIT</code>的时间为固定的60秒。</p>
<p>其定义在Linux内核代码里的名称为<code>TCP_TIMEWAIT_LEN</code>：</p>
<pre><code>#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT state, about 60 seconds  */
</code></pre><p>如果要修改<code>TIME_WAIT</code>的时间长度，只能修改Linux内核代码里 TCP_TIMEWAIT_LEN的值，并重新编译Linux内核。</p>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主动发起关闭连接的一方，才会有<code>TIME-WAIT</code>状态。</p>
<p>需要<code>TIME-WAIT</code>状态，主要是两个原因：</p>
<blockquote>
<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
</blockquote>
<p><strong><em>原因一：防止旧连接的数据包</em></strong></p>
<p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p>  <img src="/images/TCP-IP/029.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的 SEQ = 301 报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
</blockquote>
<p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p>
<p><strong><em>原因二：保证连接正确关闭</em></strong></p>
<p>在<code>RFC 793</code>指出<code>TIME-WAIT</code>另一个重要的作用是：</p>
<blockquote>
<ul>
<li>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</li>
</ul>
</blockquote>
<p>也就是说，<code>TIME-WAIT</code>作用是等待足够的时间以确保最后的<code>ACK</code>能让被动关闭方接收，从而帮助其正常关闭。</p>
<p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p>  <img src="/images/TCP-IP/030.png" style="width: 600px;"></p>
<p>没有确保正常断开的异常</p>
<blockquote>
<ul>
<li>如上图红色框框客户端四次挥手的最后一个<code>ACK</code>报文如果在网络中被丢失了，此时如果客户端<code>TIME-WAIT</code>过短或没有，则就直接进入了<code>CLOSE</code>状态了，那么服务端则会一直处在<code>LASE-ACK</code>状态。</li>
<li>当客户端发起建立连接的<code>SYN</code>请求报文后，服务端会发送<code>RST</code>报文给客户端，连接建立的过程就会被终止。</li>
</ul>
</blockquote>
<p>如果<code>TIME-WAIT</code>等待足够长的情况就会遇到两种情况：</p>
<blockquote>
<ul>
<li>服务端正常收到四次挥手的最后一个<code>ACK</code>报文，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥手的最后一个<code>ACK</code>报文时，则会重发<code>FIN</code>关闭连接报文并等待新的<code>ACK</code>报文。</li>
</ul>
</blockquote>
<p>所以客户端在<code>TIME-WAIT</code>状态等待2MSL时间后，就可以保证双方的连接都可以正常的关闭。</p>
<h3 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h3><p>如果服务器有处于<code>TIME-WAIT</code>状态的 TCP，则说明是由服务器方主动发起的断开请求。</p>
<p>过多的<code>TIME-WAIT</code>状态主要的危害有两种：</p>
<blockquote>
<ul>
<li>第一是内存资源占用；</li>
<li>第二是对端口资源的占用，一个TCP连接至少消耗一个本地端口；</li>
</ul>
</blockquote>
<p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过如下参数设置指定</p>
<pre><code>net.ipv4.ip_local_port_range
</code></pre><p>如果服务端<code>TIME_WAIT</code>状态过多，占满了所有端口资源，则会导致无法创建新连接。</p>
<h3 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h3><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<blockquote>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
</blockquote>
<p>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</p>
<p>如下的 Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。</p>
<pre><code>net.ipv4.tcp_tw_reuse = 1
</code></pre><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<pre><code>net.ipv4.tcp_timestamps = 1 #默认即为1
</code></pre><p>这个时间戳的字段是在TCP头部的「选项」里，用于记录TCP发送方的当前时间戳和从对端接收到的最新时间戳。</p>
<p>由于引入了时间戳，我们在前面提到的2MSL问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p><strong>温馨提醒</strong>：net.ipv4.tcp_tw_reuse要慎用，因为使用了它就必然要打开时间戳的支持 net.ipv4.tcp_timestamps，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。如果不能想到这种可能原因，问题排查将花费大量时间…</p>
<p>方式二：net.ipv4.tcp_max_tw_buckets</p>
<p>这个值默认为<strong>18000</strong>，当系统中处于<code>TIME_WAIT</code>的连接一旦超过这个值时，系统就会将所有的<code>TIME_WAIT</code>连接状态重置。</p>
<p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p>
<p>方式三：程序中使用 SO_LINGER</p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<pre><code>struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));
</code></pre><p>如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个<code>RST</code>标志给对端，该TCP连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP 有一个机制是保活机制。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p>在Linux内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<pre><code>net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9
</code></pre><blockquote>
<ul>
<li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
</blockquote>
<p>也就是说在 Linux 系统中，最少需要经过<strong>2小时11分15秒</strong>才可以发现一个「死亡」连接。</p>
<p>  <img src="/images/TCP-IP/031.png" style="width: 400px;"></p>
<p>这个时间是有点长的，我们也可以根据实际的需求，对以上的保活相关的参数进行设置。</p>
<p>如果开启了TCP保活，需要考虑以下几种情况：</p>
<p>第一种，对端程序是正常工作的。当TCP保活的探测报文发送给对端, 对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间的到来。</p>
<p>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</p>
<p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</p>
<h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><h3 id="针对-TCP-应该如何-Socket-编程？"><a href="#针对-TCP-应该如何-Socket-编程？" class="headerlink" title="针对 TCP 应该如何 Socket 编程？"></a>针对 TCP 应该如何 Socket 编程？</h3><p>  <img src="/images/TCP-IP/032.png" style="width: 600px;"></p>
<p>基于 TCP 协议的客户端和服务器工作</p>
<blockquote>
<ul>
<li>服务端和客户端初始化 socket，得到文件描述符；</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ul>
</blockquote>
<p>这里需要注意的是，服务端调用<code>accept</code>时，连接成功了会返回一个已完成连接的<code>socket</code>，后续用来传输数据。</p>
<p>所以，监听的<code>socket</code>和真正用来传送数据的<code>socket</code>，是「两个」<code>socket</code>，一个叫作监听<code>socket</code>，一个叫作已完成连接<code>socket</code>。</p>
<p>成功连接建立之后，双方开始通过read和write函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h3 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h3><p>Linux内核中会维护两个队列：</p>
<blockquote>
<ul>
<li>未完成连接队列（SYN 队列）：接收到一个<code>SYN</code>建立连接请求，处于<code>SYN_RCVD</code>状态；</li>
<li>已完成连接队列（Accpet 队列）：已完成TCP三次握手过程，处于<code>ESTABLISHED</code>状态；</li>
</ul>
</blockquote>
<p>下图是SYN队列和Accept队列：</p>
<p>  <img src="/images/TCP-IP/033.png" style="width: 600px;"></p>
<pre><code>int listen (int socketfd, int backlog)
</code></pre><blockquote>
<ul>
<li>参数一 socketfd 为 socketfd 文件描述符</li>
<li>参数二 backlog，这参数在历史有一定的变化</li>
</ul>
</blockquote>
<p>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</p>
<p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 backlog 是 accept 队列。</p>
<h3 id="accept-发送在三次握手的哪一步？"><a href="#accept-发送在三次握手的哪一步？" class="headerlink" title="accept 发送在三次握手的哪一步？"></a>accept 发送在三次握手的哪一步？</h3><p>我们先看看客户端连接服务端时，发送了什么？</p>
<p>  <img src="/images/TCP-IP/034.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端的协议栈向服务器端发送了<code>SYN</code>包，并告诉服务器端当前发送序列号client_isn，客户端进入<code>SYNC_SENT</code>状态；</li>
<li>服务器端的协议栈收到这个包之后，和客户端进行<code>ACK</code>应答，应答的值为 client_isn+1，表示对<code>SYN</code>包 client_isn 的确认，同时服务器也发送一个<code>SYN</code>包，告诉客户端当前我的发送序列号为server_isn，服务器端进入<code>SYNC_RCVD</code>状态；</li>
<li>客户端协议栈收到<code>ACK</code>之后，使得应用程序从connect调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为<code>ESTABLISHED</code>，同时客户端协议栈也会对服务器端的<code>SYN</code>包进行应答，应答数据为server_isn+1；</li>
<li>应答包到达服务器端后，服务器端协议栈使得accept阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入<br><code>ESTABLISHED</code>状态。</li>
</ul>
</blockquote>
<p>从上面的描述过程，我们可以得知客户端connect成功返回是在第二次握手，服务端accept成功返回是在三次握手成功之后。</p>
<h3 id="客户端调用-close-了，连接是断开的流程是什么？"><a href="#客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么？"></a>客户端调用 close 了，连接是断开的流程是什么？</h3><p>我们看看客户端主动调用了 close，会发生什么？</p>
<p>  <img src="/images/TCP-IP/035.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端调用close，表明客户端没有数据需要发送了，则此时会向服务端发送<code>FIN</code>报文，进入<code>FIN_WAIT_1</code>状态；</li>
<li>服务端接收到了<code>FIN</code>报文，TCP协议栈会为<code>FIN</code>包插入一个文件结束符 EOF到接收缓冲区中，应用程序可以通过read调用来感知这个<code>FIN</code>包。这个 EOF会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为EOF表示在该连接上再无额外数据到达。此时，服务端进入<code>CLOSE_WAIT</code>状态；</li>
<li>接着，当处理完数据后，自然就会读到EOF，于是也调用close关闭它的套接字，这会使得会发出一个<code>FIN</code>包，之后处于<code>LAST_ACK</code>状态；</li>
<li>客户端接收到服务端的<code>FIN</code>包，并发送<code>ACK</code>确认包给服务端，此时客户端将进入<code>TIME_WAIT</code>状态；</li>
<li>服务端收到<code>ACK</code>确认包后，就进入了最后的<code>CLOSE</code>状态；</li>
<li>客户端进过2MSL时间之后，也进入<code>CLOSED</code>状态；</li>
</ul>
</blockquote>
<p><strong><em>巨人的肩膀</em></strong></p>
<blockquote>
<ul>
<li>[1] 趣谈网络协议专栏.刘超.极客时间.</li>
<li>[2] 网络编程实战专栏.盛延敏.极客时间.</li>
<li>[3] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社</li>
<li>[4] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社</li>
<li>[5] 图解TCP/IP.竹下隆史.人民邮电出版社</li>
<li>[6] <a href="https://www.rfc-editor.org/rfc/rfc793.html" target="_blank" rel="external">https://www.rfc-editor.org/rfc/rfc793.html</a></li>
<li>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake" target="_blank" rel="external">https://draveness.me/whys-the-design-tcp-three-way-handshake</a></li>
<li>[8] <a href="https://draveness.me/whys-the-design-tcp-time-wait" target="_blank" rel="external">https://draveness.me/whys-the-design-tcp-time-wait</a></li>
</ul>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> Internet Protocol </tag>
            
            <tag> TCP-IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针浅谈]]></title>
      <url>/2020/05/04/%E6%8C%87%E9%92%88%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<p><img src="/images/Pointer/Pointer_Background.jpg" alt="post-cover"></p>
<p>此篇博客是由日常阅读、总结的文章，旨在通过通俗易懂的文字理解C/C++中的指针。<br>目录一览：</p>
<blockquote>
<ul>
<li>什么是指针</li>
<li>指针与数组</li>
<li>new和delete，申请、释放内存空间</li>
</ul>
</blockquote>
<hr>
<h2 id="一、什么是指针？"><a href="#一、什么是指针？" class="headerlink" title="一、什么是指针？"></a>一、什么是指针？</h2><!-- &nbsp;表示一个空格 -->
<p>首先，提一句我看到过的让我理解指针最形象的比喻：<strong>变量和指向该变量的指针是同一个硬币的两面</strong>。我们从以下代码片段进行阐述：</p>
<pre><code>int value = 5;//①
int* pointer = &amp;value;//②
cout &lt;&lt; pointer &lt;&lt; endl;//③
cout &lt;&lt; *pointer &lt;&lt; endl;//④
</code></pre><blockquote>
<ul>
<li>①表示变量value的值是5，数据类型int，int类型占用存储空间一般是4个字节，因为计算机世界里只有0和1，所以变量value在<code>大端模式</code>的计算机世界里是长这个样子的:00000000 00000000 00000000 00000101,其中8个bit表示1个byte。不同的数据类型，其存储空间大小不一样，可以理解为不同大小的鞋子应该放在不同大小的鞋盒里面。value存储在计算机某块内存中，内存地址对程序员不直接可见，这里假设我们使用的机器是32位的，并假设变量value的内存地址的值的16进制表示为0x12345678</li>
<li>②表示指针变量pointer指向变量value的地址，可以把这一行中的＆符号理解为”取地址操作”，只有取地址操作后，等于号”=”右边的值才是指针类型，类型相同才能赋值这是基础语法。</li>
<li>③是C++语法的输出语句，效果同C中println，其输出值为0x12345678，说明指针变量的值就是它所指向的变量value的内存地址的值，pointer既然也称之为变量，那就一定也要占据存储空间，指针的大小由<code>内存寻址空间</code>决定（即x86还是x64），刚才说pointer的值是0x12345678，所以它在大端模式计算机里长这样:00010010 00110100 01010110 01111000</li>
<li>④也是输出语句，输出值为5，表示指针变量pointer所指向的那个地址的实际存储的内容是整数5，这里<code>*</code>符号理解为”解引用操作”，意思就是把pointer指针指向的地址的值取出来。</li>
</ul>
</blockquote>
<p>所以，实际上，指针变量pointer的值是变量value的地址，变量value的值既可以用指向它自己的指针通过”解引用操作”表示，又能用该变量自己表示。</p>
<p><strong><em>那为什么需要指针这个概念呢？</em></strong></p>
<p>我个人的理解是便于操作，减少变量，因为指针也可以加1减1这样操作的，比如说上面提到的指针pointer+1，结果将是0x1234567C，因为pointer存储空间是4个字节，它加1相当于把它指向的地址往后移动4个字节(16进制的8加上4等于C，不需要进位，所以前面的7不变)，假如我有一万个在存储空间中相邻排布的相同类型的变量，我可以用一个该类型的指针变量表示这一万个值，因为我移动该指针的地址就行了，然后”解引用操作”取出该地址存储的值。你可能会说我也可以用a表示所有啊，a=3，用完之后a=4，并非如此，你说的这个a在它的作用域内的地址是固定的，从3改为4是指把a实际存储的值变化了，用指针当然也可以改变其中实际的值，不过更多的是通过一个指针变量取出存储在不同地址的值。另外值得一提到是，上面说的指针变量pointer，刚才只说了它的值是value的地址，那它肯定也有自己的地址啊，没错，它肯定也有地址，它的地址将会是某个二级指针的值，也就是<code>**</code>这个玩意儿了。</p>
<hr>
<p><strong>脚下留心：</strong></p>
<p><strong>1.大端模式与小端模式</strong></p>
<p>大小端的问题是由CPU决定的，它表示的是对内存中排布的数据的不同解析方式。</p>
<p>假设一个占4个byte的int类型变量的值固定是0x12345678（其中我们称12在高字节位，78在低字节位）。如果该变量在内存空间中如下排布（其中我们称0x100在低地址位，0x103在高地址位），则表示高字节位的12排布在低地址0x100上，说明此款CPU是以大端方式进行解析的。</p>
<table>
<thead>
<tr>
<th>数据存储地址</th>
<th style="text-align:center">…</th>
<th style="text-align:center">0x100</th>
<th style="text-align:center">0x101</th>
<th style="text-align:center">0x102</th>
<th style="text-align:center">0x103</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据存储值</strong></td>
<td style="text-align:center"><strong>…</strong></td>
<td style="text-align:center"><strong>12</strong></td>
<td style="text-align:center"><strong>34</strong></td>
<td style="text-align:center"><strong>56</strong></td>
<td style="text-align:center"><strong>78</strong></td>
<td><strong>…</strong></td>
</tr>
</tbody>
</table>
<p>如果该变量在内存空间中如下排布，则表示高字节位的12排布在高地址0x103上，说明此款CPU是以小端方式进行解析的。</p>
<table>
<thead>
<tr>
<th>数据存储地址</th>
<th style="text-align:center">…</th>
<th style="text-align:center">0x100</th>
<th style="text-align:center">0x101</th>
<th style="text-align:center">0x102</th>
<th style="text-align:center">0x103</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据存储值</strong></td>
<td style="text-align:center"><strong>…</strong></td>
<td style="text-align:center"><strong>78</strong></td>
<td style="text-align:center"><strong>56</strong></td>
<td style="text-align:center"><strong>34</strong></td>
<td style="text-align:center"><strong>12</strong></td>
<td><strong>…</strong></td>
</tr>
</tbody>
</table>
<p><strong>2.内存寻址空间</strong></p>
<p>我们都听说过x86操作系统和x64操作系统的概念，其实就是说32位和64位操作系统，但与之对应的应该是硬件处理器CPU，操作系统本质上还是一款软件，它的绝对性能取决于底层硬件设备。什么是内存寻址空间？我们知道32位的CPU连接32根地址线，那么它总共可以表示2^32个内存地址，每个内存地址指向内存中的一个byte，所以总共2^32bytes=4G，即32位的电脑最多可利用的内存空间是4G，亦即32位的电脑只需配4G的内存条就够了，多了也是浪费，根本利用不上。</p>
<hr>
<h2 id="二、指针与数组"><a href="#二、指针与数组" class="headerlink" title="二、指针与数组"></a>二、指针与数组</h2><p>惯例，先上代码段：</p>
<pre><code>int arrayA[3] = {6, 7, 8};//①
int* p_arrayA = arrayA;//②
</code></pre><blockquote>
<ul>
<li>①是初始化一个长度为3的int型数组<code>arrayA</code></li>
<li>②是将一个int类型指针<code>p_arrayA</code>指向该数组</li>
</ul>
</blockquote>
<p>这两行代码不报错说明什么呢？说明数组名其实可以当做指针，该指针指向本数组中首个元素，即6所在的地址，而指针<code>p_arrayA</code>也指向数组的首个元素的地址。</p>
<p><em>它俩有什么区别？</em></p>
<blockquote>
<ul>
<li>指针的值可修改，而数组名是常量。这里提到常量，常量指不可更改的值，比如说出生日期。常量相对而言的是变量，比如说年龄。刚才提到的<code>p_arrayA</code>是变量，<code>arrayA</code>是常量对应代码的表现就是:<br><code>p_arrayA = p_arrayA + 1； // 合理</code><br><code>arrayA = arrayA + 1；// 报错</code><br>虽然不能显式的给<code>arrayA</code>重新赋值，但是用它来取值是可以的，比如说<code>arrayA[1]</code>和<code>*(arrayA+1)</code>都是数组<code>arrayA</code>的第二个变量的值，即7。</li>
<li>对数组名应用sizeof运算符得到的是该数组的占用内存空间的大小(单位是byte)，对指针应用sizeof运算符得到的是该类型的指针变量的大小。<br><em>为什么说sizeof是运算符？</em><br>因为sizeof返回的单位是byte，即变量实际占用的内存大小，而<code>size（）</code>或者<code>length（）</code>这样的函数返回值一般是数组的长度，即数组成员是多少个。</li>
</ul>
</blockquote>
<p>综上，数组名<code>arrayA</code>可以当做指针用，所以以后看到<code>*(arrayA++)</code>这样的代码不要奇怪。最后，我曾经自己写例子得到指向<code>&amp;arrayA</code>的指针是一个<code>int(*)[3]</code>类型的，<code>int(*)[3]</code>可以理解为长度为3的int类型数组的指针。</p>
<hr>
<h2 id="三、new和delete，申请、释放内存空间"><a href="#三、new和delete，申请、释放内存空间" class="headerlink" title="三、new和delete，申请、释放内存空间"></a>三、new和delete，申请、释放内存空间</h2><p>C++中使用new和delete关键字对内存进行分配和回收，C中使用malloc和free。</p>
<p><strong><em>1.使用new申请的内存空间为什么需要用delete释放？</em></strong></p>
<p>举个例子：</p>
<p>你租用了政府一块地（new），并在上面盖了个房子（初始化），并在里面住了一段时间，做了一些事情（使用）。当你使用期限到了， 你应该把地归还政府（delete），公有制不是你想造作就能造作的，人人都申请不归还，白嫖？难不成你想被请去喝茶（计算机资源有限）。</p>
<p><strong><em>2.被delete了的内存空间为什么不要再使用？</em></strong></p>
<p>接上一个例子：</p>
<p>你把地归还给政府后，政府这时只是登记一下，某块地现在已经空闲了，它并不会去清除那块地上的房子，但政府随时可能把地提供给其他大老板，虽然房子可能暂时还没拆，但如果你继续住在里面的话（访问已释放的内存），你随时都可能在梦中被推土机碾成肉酱。</p>
<p><strong><em>3.delete一定要作用于被new的那个变量吗？</em></strong></p>
<p>不是，delete只要作用于被new的地址就行了。<br>比如以下代码段：</p>
<pre><code>int* ps = new int；// allocate memory
int* pq = ps;// set second pointer to same block
delete pq;// delete with second pointer
ps = NULL;
pq = NULL;
</code></pre><p>以上代码仍然可以释放被new申请的内存空间，而不一定非要<code>delete ps;</code>。</p>
<p><strong><em>4.接上一个代码段，为什么要将指针变量显式地置为NULL？</em></strong></p>
<p>delete一个指针后，编译器只会释放该指针指向的内存空间，而不会删除这个指针本身，且指针重新指向一个未知地址，置为NULL之后再次使用该指针编译器将报错，可以避免后续代码无意使用该指针造成的难以预料的问题，即避免问题2中提到的“被碾成肉酱”。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 个人小结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Internet Protocol(1)]]></title>
      <url>/2017/08/12/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE(%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%A7%92%E5%BA%A6%E8%A7%A3%E8%AF%BB)/</url>
      <content type="html"><![CDATA[<p>  <img src="/images/InternetProtocol/Background.jpg" alt="post-cover"><br>参考链接：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">阮一峰前辈的学习博客</a></p>
<hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>你是否有过疑惑，全球几十亿台计算机是<code>如何</code>通过互联网实现信息传递的？</p>
<p>下面是我参考各前辈的学习笔记写下的关于互联网协议的文章。因为这些协议实在太复杂、太庞大，在这里整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，其中做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。</p>
<hr>
<h2 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h2><h3 id="2-1-七层模型"><a href="#2-1-七层模型" class="headerlink" title="2.1 七层模型"></a>2.1 七层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p>
<p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p>
<p>下面是ISO定义网络的标准层次模型。</p>
<p>  <img src="/images/InternetProtocol/one.png" style="width: 800px;"></p>
<p>如上图所示，最底下的一层叫做”物理层”-<code>Physical Layer</code>，最上面的一层叫做”应用层”-<code>Application Layer</code>，中间的五层（自下而上）分别是”链接层”-<code>Link Layer</code>、”网络层”-<code>Network Layer</code>、”传输层”-<code>Transport Layer</code>、”会话层”-<code>Session Layer</code>和”表现层”-<code>Presentation layer</code>。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p>
<h3 id="2-2-层与协议"><a href="#2-2-层与协议" class="headerlink" title="2.2 层与协议"></a>2.2 层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p>
<p>大家都遵守的规则，就叫做”协议”-<code>protocol</code>。</p>
<p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”-<code>Internet Protocol Suite</code>。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p>
<hr>
<h2 id="三、物理层"><a href="#三、物理层" class="headerlink" title="三、物理层"></a>三、物理层</h2><p>我们从最底下的一层开始。</p>
<p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p>
<p>  <img src="/images/InternetProtocol/two.png" style="width: 600px;"></p>
<p><strong>这就叫做”物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>
<hr>
<h2 id="四、链接层"><a href="#四、链接层" class="headerlink" title="四、链接层"></a>四、链接层</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p><strong>这就是”链接层”的功能，它在”物理层”的上方，确定了0和1的分组方式。</strong></p>
<h3 id="4-2-以太网协议"><a href="#4-2-以太网协议" class="headerlink" title="4.2 以太网协议"></a>4.2 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="external">以太网</a>“-<code>Ethernet</code>的协议，占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做”<a href="https://zh.wikipedia.org/wiki/%E5%B8%A7" target="_blank" rel="external">帧</a>“-<code>Frame</code>。每一帧分成两个部分：标头-<code>Head</code>和数据-<code>Data</code>。</p>
<p>  <img src="/images/InternetProtocol/three.png" style="width: 600px;"></p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="4-3-MAC地址"><a href="#4-3-MAC地址" class="headerlink" title="4.3 MAC地址"></a>4.3 MAC地址</h3><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做<code>MAC</code>地址。</p>
<p>  <img src="/images/InternetProtocol/four.jpg" style="width: 450px;"></p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的<code>MAC</code>地址，长度是48个二进制位，通常用12个<code>十六进制</code>数表示。</p>
<p>  <img src="/images/InternetProtocol/five.png" style="width: 450px;"></p>
<p>前6个<code>十六进制</code>数是厂商编号，后6个是该厂商的网卡流水号。有了<code>MAC</code>地址，就可以定位网卡和数据包的路径了。</p>
<h3 id="4-4-广播"><a href="#4-4-广播" class="headerlink" title="4.4 广播"></a>4.4 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p>
<p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p>
<p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的<code>MAC</code>地址，然后才能发送。</p>
<p>其次，就算有了<code>MAC</code>地址，系统怎样才能把数据包准确送到接收方？</p>
<p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<p>  <img src="/images/InternetProtocol/six.png" style="width: 600px;"></p>
<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的<code>MAC</code>地址，然后与自身的<code>MAC</code>地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”<a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF" target="_blank" rel="external">广播</a>“-<code>broadcasting</code>。</p>
<p>有了数据包的定义、网卡的<code>MAC</code>地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p>
<hr>
<h2 id="五、网络层"><a href="#五、网络层" class="headerlink" title="五、网络层"></a>五、网络层</h2><h3 id="5-1-网络层的由来"><a href="#5-1-网络层的由来" class="headerlink" title="5.1 网络层的由来"></a>5.1 网络层的由来</h3><p>以太网协议，依靠<code>MAC</code>地址发送数据。理论上，单单依靠<code>MAC</code>地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p>
<p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p>
<p>  <img src="/images/InternetProtocol/seven.png" style="width: 600px;"></p>
<p>因此，必须找到一种方法，能够区分哪些<code>MAC</code>地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，<code>MAC</code>地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是<code>MAC</code>地址，另一种是网络地址。两种地址之间没有任何联系，<code>MAC</code>地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，<code>MAC</code>地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理<code>MAC</code>地址。</p>
<h3 id="5-2-IP协议"><a href="#5-2-IP协议" class="headerlink" title="5.2 IP协议"></a>5.2 IP协议</h3><p>规定网络地址的协议，叫做<code>IP</code>协议。它所定义的地址，就被称为<code>IP</code>地址。</p>
<p>目前，广泛采用的是<code>IP</code>协议第四版，简称IPv4。这个版本规定，网络地址由32个<code>二进制</code>位组成。</p>
<p>  <img src="/images/InternetProtocol/eight.png" style="width: 450px;"></p>
<p>习惯上，我们用分成四段的十进制数表示<code>IP</code>地址，从<strong>0.0.0.0</strong>一直到<strong>255.255.255.255</strong>。</p>
<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，<code>IP</code>地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>
<p>但是，问题在于单单从<code>IP</code>地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从<code>IP</code>地址上是看不出来的。</p>
<p>那么，怎样才能从<code>IP</code>地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%BD%91#.E7.BD.91.E7.BB.9C.E6.8E.A9.E7.A0.81" target="_blank" rel="external">子网掩码</a>“-<code>subnet mask</code>。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，<code>IP</code>地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个<code>IP</code>地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是<strong>255.255.255.0</strong>，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p><strong>总结一下，<code>IP</code>协议的作用主要有两个，一个是为每一台计算机分配<code>IP</code>地址，另一个是确定哪些地址在同一个子网络。</strong></p>
<h3 id="5-3-IP数据包"><a href="#5-3-IP数据包" class="headerlink" title="5.3 IP数据包"></a>5.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做<code>IP</code>数据包。不难想象，其中必定包括<code>IP</code>地址信息。</p>
<p>但是前面说过，以太网数据包只包含<code>MAC</code>地址，并没有<code>IP</code>地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p>
<p>回答是不需要，我们可以把<code>IP</code>数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p>
<p>具体来说，<code>IP</code>数据包也分为”标头”和”数据”两个部分。</p>
<p>  <img src="/images/InternetProtocol/nine.png" style="width: 600px;"></p>
<p>“标头”部分主要包括版本、长度、<code>IP</code>地址等信息，”数据”部分则是<code>IP</code>数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p>
<p>  <img src="/images/InternetProtocol/ten.png" style="width: 600px;"></p>
<p><code>IP</code>数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个<code>IP</code>数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果<code>IP</code>数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h3 id="5-4-ARP协议"><a href="#5-4-ARP协议" class="headerlink" title="5.4 ARP协议"></a>5.4 ARP协议</h3><p>关于”网络层”，还有最后一点需要说明。</p>
<p>因为<code>IP</code>数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的<code>MAC</code>地址，另一个是对方的<code>IP</code>地址。通常情况下，对方的<code>IP</code>地址是已知的（后文会解释），但是我们不知道它的<code>MAC</code>地址。</p>
<p>所以，我们需要一种机制，能够从<code>IP</code>地址得到<code>MAC</code>地址。</p>
<p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的<code>MAC</code>地址，只能把数据包传送到两个子网络连接处的”<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3" target="_blank" rel="external">网关</a>“-<code>gateway</code>，让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的<code>MAC</code>地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的<code>IP</code>地址，在对方的<code>MAC</code>地址这一栏，填的是<strong>FF:FF:FF:FF:FF:FF</strong>，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出<code>IP</code>地址，与自身的<code>IP</code>地址进行比较。如果两者相同，都做出回复，向对方报告自己的<code>MAC</code>地址，否则就丢弃这个包。</p>
<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机<code>MAC</code>地址，可以把数据包发送到任意一台主机之上了。</p>
<hr>
<h2 id="六、传输层"><a href="#六、传输层" class="headerlink" title="六、传输层"></a>六、传输层</h2><h3 id="6-1-传输层的由来"><a href="#6-1-传输层的由来" class="headerlink" title="6.1 传输层的由来"></a>6.1 传输层的由来</h3><p>有了<code>MAC</code>地址和<code>IP</code>地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%9F%A0" target="_blank" rel="external">端口</a>“-<code>port</code>，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</strong>因此，Unix系统就把主机+端口，叫做”<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7" target="_blank" rel="external">套接字</a>“-<code>socket</code>。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="6-2-UDP协议"><a href="#6-2-UDP协议" class="headerlink" title="6.2 UDP协议"></a>6.2 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由”标头”和”数据”两部分组成。</p>
<p>  <img src="/images/InternetProtocol/eleven.png" style="width: 600px;"></p>
<p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入<code>IP</code>数据包的”数据”部分，而前面说过，<code>IP</code>数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p>
<p>  <img src="/images/InternetProtocol/twelve.png" style="width: 600px;"></p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个<code>IP</code>数据包。</p>
<h3 id="6-3-TCP协议"><a href="#6-3-TCP协议" class="headerlink" title="6.3 TCP协议"></a>6.3 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在<code>IP</code>数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<hr>
<h2 id="七、会话层"><a href="#七、会话层" class="headerlink" title="七、会话层"></a>七、会话层</h2><p>会话层利用传输层来提供会话服务，会话可能是一个用户通过网络登录到一个主机，或一个正在建立的用于传输文件的会话。<br>会话层的功能主要有：会话连接到传输连接的映射、数据传送、会话连接的恢复和释放、会话管理、令牌管理和活动管理。 </p>
<hr>
<h2 id="八、表示层"><a href="#八、表示层" class="headerlink" title="八、表示层"></a>八、表示层</h2><p>表示层用于数据管理的表示方式，如用于文本文件的ASCII和EBCDIC，用于表示数字的1S或2S补码表示形式。如果通信双方用不同的数据表示方法，他们就不能互相理解。表示层就是用于屏蔽这种不同之处。<br>表示层的功能主要有：数据语法转换、语法表示、表示连接管理、数据加密和数据压缩。 </p>
<hr>
<h2 id="九、应用层"><a href="#九、应用层" class="headerlink" title="九、应用层"></a>九、应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>
<p>  <img src="/images/InternetProtocol/thirteen.png" style="width: 600px;"></p>
<p>至此，整个互联网的七层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> Internet Protocol </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建网站教程]]></title>
      <url>/2017/08/06/Hexo/</url>
      <content type="html"><![CDATA[<p><img src="/images/Background.jpg" alt="post-cover"></p>
<p>这是第一篇博客，主要介绍hexo搭建网站的过程<br><a id="more"></a></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title=" 1.前言"></a> 1.前言</h1><p><strong>使用github pages服务搭建博客的好处有：</strong></p>
<blockquote>
<p>1.全是静态文件访问速度快<br>  2.免费方便，不花一分钱就能搭建一个自由的个人博客<br>  3.可以绑定自己的域名，不仔细看看不出是github的</p>
</blockquote>
<h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title=" 1.1  准备工作"></a> 1.1  准备工作</h2><blockquote>
<p><strong>注意：</strong>在开始一切之前，你必须已经：</p>
<ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
</blockquote>
<p> <strong>本文所使用的环境：</strong></p>
<blockquote>
<ul>
<li>window8.1 x 64</li>
<li>node.js    6.11.x</li>
<li>git     2.12.x</li>
<li>hexo   </li>
</ul>
</blockquote>
<h1 id="2-搭建github博客"><a href="#2-搭建github博客" class="headerlink" title=" 2.搭建github博客"></a> 2.搭建github博客</h1><h2 id="2-1创建仓库"><a href="#2-1创建仓库" class="headerlink" title=" 2.1创建仓库"></a> 2.1创建仓库</h2><blockquote>
<p>1.新建一个名字为<code>你的用户名.github.io</code>的仓库,以我自己的用户名为例,我的用户名为JiangLingJun，那么我的仓库名就是<code>JiangLingJun.github.io</code><br>2.你将来的博客的网址即为 <a href="https://JiangLingJun.github.io" target="_blank" rel="external">https://JiangLingJun.github.io</a></p>
</blockquote>
<p>脚下留心：</p>
<blockquote>
<p>1.注册邮箱一定要验证，否则建不了仓库<br>2.仓库名称必须是： <code>你的用户名.github.io</code>,其中你的用户名必须和你登录的一样<br>3.仓库的创建不会立即生效，有可能需要等10~30分钟，或者更久</p>
</blockquote>
<h2 id="2-2绑定域名"><a href="#2-2绑定域名" class="headerlink" title="2.2绑定域名"></a>2.2绑定域名</h2><ul>
<li>你不绑定域名也是可以的，那你就默认访问 xxx.github.io就好</li>
<li>但是我们都想个性一点，拥有我们自己的域名不是吗？我这里用的是阿里云购买的一个域名，价格也不太贵，对学生还有优惠。</li>
<li><p>域名绑定有2种方式，CNAME和A记录，CNAME是要填写域名的，A是要填写IP 的。<br>1.A记录型（填写ip），你需要ping一下 <code>你的用户名.github.io</code> 然后将ip地址和域名进行绑定<br>2.CNAME型（填写域名），需要你将自己的域名和github的域名进行 绑定<br><img src="/images/CreateMyBlog01.png" style="width: 600px;"></p>
<p>然后你要到自己的github项目的根目录下新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你的喜好，因为经过测试</p>
</li>
</ul>
<blockquote>
<ul>
<li>如果你填写的是没有www的，比如 yoursite.xyz 那么无论访问 <a href="http://yoursize.xyz" target="_blank" rel="external">http://yoursize.xyz</a> 还是 <a href="http://yoursite.xyz" target="_blank" rel="external">http://yoursite.xyz</a> 都会自动跳转到 <a href="http://yoursite.xyz" target="_blank" rel="external">http://yoursite.xyz</a></li>
<li>如果你写的是带www的，比如  www.yoursite.xyz  那么无论是访问 <a href="http://www.yoursite.xyz" target="_blank" rel="external">http://www.yoursite.xyz</a> 还是 <a href="http://yoursite.xyz都会自动跳转到" target="_blank" rel="external">http://yoursite.xyz都会自动跳转到</a> <a href="http://www.yoursite.xyz" target="_blank" rel="external">http://www.yoursite.xyz</a></li>
<li>如果你填写其他的子域名，比如 aaa.yoursite.xyz ,那么访问 <a href="http://aaa.yoursite.xyz" target="_blank" rel="external">http://aaa.yoursite.xyz</a> 没有问题，但是访问 <a href="http://yoursite.xyz" target="_blank" rel="external">http://yoursite.xyz</a> 不会跳转到 <a href="http://abc.yoursite.xyz" target="_blank" rel="external">http://abc.yoursite.xyz</a></li>
</ul>
</blockquote>
<p>补充：在绑定域名后，原来的域名<code>你的用户名.github.io</code>，没有失效而是会自动跳转的你的新域名。</p>
<h1 id="3-配置-SSH-key"><a href="#3-配置-SSH-key" class="headerlink" title="3.配置 SSH key"></a>3.配置 SSH key</h1><p>配置原因：提交代码到github需要权限，但是直接使用用户名和密码 不安全，我们使用ssh key来解决本地和服务器之间的连接问题</p>
<pre><code>$cd ~/.ssh  #检查本地存在的ssh秘钥
</code></pre><p>如果提示：No such file or directory 说明你是第一次使用git</p>
<pre><code>ssh-keygen -t rsa -C &quot;邮箱地址&quot;
</code></pre><p>然后连续3次回车，最终会生成ssh key在用户的目录下，打开你自己的用户目录 ，在里面找到 .ssh\id_rsa.pub 文件，记事本打开，并且复制里面内容，然后打开你的github主页， 进入个人设置 –》 SSH and GPG keys – 》 New SSH key<br><img src="/images/CreateMyBlog02.png" style="width: 600px;"></p>
<p>然后将刚复制的内容粘贴到key那里，title随便填，保存</p>
<h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><pre><code>$ ssh -T git@github.com
</code></pre><p>如果提示<code>Are you sure you want to continue to connecting(yes/no)?</code>,然后输入yes，然后会看到</p>
<blockquote>
<p>hi ，xxx ! You’ve successfully authenticated , but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个说明SSH配置成功<br>此时你还需要配置：</p>
<pre><code>$ git config --global user.name &quot;xxx&quot;  # 你的github用户名
$ git config --global user.email &quot;xxx&quot;   # 你的邮箱名 
</code></pre><h1 id="4-使用hexo写博客"><a href="#4-使用hexo写博客" class="headerlink" title="4.使用hexo写博客"></a>4.使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1 hexo简介"></a>4.1 hexo简介</h2><p>hexo 是一个简单、快速、强大的基于github pages 的博客发布工具，支持Markdown格式，有许多优秀插件和主题</p>
<p>官网：  <a href="http://hexo.io" target="_blank" rel="external">http://hexo.io</a><br>github :  <a href="https://github.com/hexojs/hexo" target="_blank" rel="external">https://github.com/hexojs/hexo</a></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2 原理"></a>4.2 原理</h2><p>   由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
<h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h2><p>脚下留心：</p>
<blockquote>
<p>1.很多命令既可以用windows的cmd来完成，也可以用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；<br>2.hexo不同版本的差别较大，网上很多文章是基于2.x的，不要被误导<br>3.hexo有两种_config.yml文件，一个是根目录下的全局的_config.yml,一个是themes下的</p>
</blockquote>
<h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4 安装"></a>4.4 安装</h2><p>注意要先安装 node.js ，这里不再详细说明</p>
<pre><code>$npm install -g hexo
</code></pre><h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5 初始化"></a>4.5 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是 F:\Hexo ,由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<pre><code>$cd /f/Hexo 
$hexo  init
</code></pre><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p>
<p><img src="/images/CreateMyBlog03.png" style="width: 600px;"></p>
<pre><code>$hexo g #生成
$hexo s #启动服务
</code></pre><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p>
<p><img src="/images/CreateMyBlog04.png" style="width: 600px;"><br>hexo s是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p>
<p><a href="http://blog.liuxianan.com/windows-port-bind.html" target="_blank" rel="external">http://blog.liuxianan.com/windows-port-bind.html</a></p>
<p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p>
<p><img src="/images/CreateMyBlog05.png" style="width: 600px;"></p>
<h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6 修改主题"></a>4.6 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="external">官方主题</a></p>
<p>我自己选的主题 <a href="https://github.com/Haojen/hexo-theme-Claudia.git" target="_blank" rel="external">hexo-theme-Claudia</a></p>
<p>首先下载这个主题：</p>
<pre><code>$ cd /d/Hexo
$ git clone https://github.com/Haojen/hexo-theme-Claudia.git  themes/Claudia
</code></pre><p>下载后的主题在这里：</p>
<p><img src="/images/CreateMyBlog06.png" style="width: 600px;"></p>
<p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: Claudia</code>，然后重新执行hexo g来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p>
<h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7 上传之前"></a>4.7 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p>
<h2 id="4-8-上传到github上"><a href="#4-8-上传到github上" class="headerlink" title="4.8 上传到github上"></a>4.8 上传到github上</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p>
<p>首先，ssh key肯定要配置好。</p>
<p>其次，配置_config.yml中有关deploy的部分：</p>
<p>正确写法：</p>
<pre><code>deploy:
    type: git
    repository: git@github.com:你的用户名/你的用户名.github.io.git
    branch: master
</code></pre><p>脚下留心： <strong>type及后面的repository，branch的冒号后面一定要有空格</strong></p>
<p>直接执行<code>hexo d</code>的话一般会报如下错误：</p>
<pre><code>Deployer not found: github 或者 Deployer not found: git
</code></pre><p>原因是需要安装一个插件，部署这个命令一定要用git bash：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>最后输入<code>hexo d</code>将代码全部提交到github上。</p>
<h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10 常用hexo命令"></a>4.10 常用hexo命令</h2><pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
</code></pre><h1 id="5-博客的编写"><a href="#5-博客的编写" class="headerlink" title="5 博客的编写"></a>5 博客的编写</h1><h2 id="5-1-博客一般格式"><a href="#5-1-博客一般格式" class="headerlink" title="5.1 博客一般格式"></a>5.1 博客一般格式</h2><pre><code> ---
 title: postName #文章页面上的显示名称，一般是中文
 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改
 categories: 默认分类 #分类
 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格
 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
 ---

以下是正文
</code></pre><h2 id="5-2-正文的编写语法"><a href="#5-2-正文的编写语法" class="headerlink" title="5.2 正文的编写语法"></a>5.2 正文的编写语法</h2><p> 我这里用的Markdown，用的软件是一款在线编辑工具<a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a>，当然网上还有许多编辑工具，大家可以自己去查</p>
<h2 id="最后的说明–编辑文件的位置：source下的posts下的md文件"><a href="#最后的说明–编辑文件的位置：source下的posts下的md文件" class="headerlink" title=" 最后的说明–编辑文件的位置：source下的posts下的md文件"></a> 最后的说明–编辑文件的位置：source下的posts下的md文件</h2><p>本文的参考文章:<a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="external">http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>
<p>详细的编写博客的教程，可以去百度：hexo编写博客</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 个人网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/03/hello-world/</url>
      <content type="html"><![CDATA[<p><img src="/images/HelloWorld.jpg" alt="post-cover"></p>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> foo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[VPN]]></title>
      <url>/2020/05/23/VPN/</url>
      <content type="html"><![CDATA[<p><img src="/images/VPS/VPN.jpg" alt="post-cover"></p>
<p>此篇文章共享自己搭建VPS生成的VPN账号,有心人可以尝试配置并看看墙外的世界。</p>
<p>tips:<br>①.流量有限，温柔点，别乱来；<br>②.IP若被封随时更改，有梯子需求的朋友可私信我获取。</p>
<hr>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><blockquote>
<ul>
<li>首先，联网并装了百度网盘的电脑</li>
<li>第二，好像没了…</li>
</ul>
</blockquote>
<h2 id="二、安装必要工具"><a href="#二、安装必要工具" class="headerlink" title="二、安装必要工具"></a>二、安装必要工具</h2><p>VPN软件PC版–<a href="https://pan.baidu.com/s/1X4u9Z7hJMLSUDgk8DrehDA" target="_blank" rel="external">解压缩运行即可</a><br>提取码:<code>as94</code></p>
<p>VPN软件Android版–<a href="https://pan.baidu.com/s/1N3th30ilZ0D-DjX8Zhvfnw" target="_blank" rel="external">解压缩发送到安卓手机安装</a><br>提取码:<code>nyxm</code></p>
<h2 id="三、配置信息"><a href="#三、配置信息" class="headerlink" title="三、配置信息"></a>三、配置信息</h2><p>①.运行PC版VPN软件后，看以下截图进行配置，点击“确认”：</p>
<p><img src="/images/VPS/123.png" style="width: 600px;"></p>
<p>②.代理模式也配置一下：</p>
<p><img src="/images/VPS/1234.png" style="width: 300px;"></p>
<p>③.配置就绪后点击链接–<a href="https://www.google.com/" target="_blank" rel="external">Google</a>。以后每次启动纸飞机就能访问外网了。</p>
<p>④.安卓手机安装好VPN软件后配置服务器地址、服务器端口、密码和加密方式就可以，这些信息上面截图都有。</p>
<p>⑤.有任何疑问请私信。</p>
<p>上面这些仅仅是客户端的配置，服务器那边也都是自己网上搜罗教程租用VPS来搭的，之前写过搭梯子博客教程但是被封，毕竟多多少少政治敏感，墙外的负面消息多，真假难辨。</p>
<hr>
<p><strong><em>最后</em></strong></p>
<p>技术无罪，共享精神无罪，但是，别干坏事，做个好人。</p>
<p><strong>当你凝视深渊时，深渊也在凝视你</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> 天梯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常识-人事档案相关]]></title>
      <url>/2020/05/05/%E5%B8%B8%E8%AF%86-%E4%BA%BA%E4%BA%8B%E6%A1%A3%E6%A1%88%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p><img src="/images/GeneralKnowledge/BackGround.png" alt="post-cover"></p>
<p>此篇博客内容整理自网络，主要介绍人事档案相关。<br>目录一览：</p>
<blockquote>
<ul>
<li>什么是人事档案</li>
<li>档案的作用</li>
<li>档案该怎么操作才能不当“弃档族”</li>
<li>档案成为“死档”的几种原因</li>
<li>档案不小心成为“死档”的处理方法</li>
</ul>
</blockquote>
<hr>
<h2 id="一、什么是人事档案"><a href="#一、什么是人事档案" class="headerlink" title="一、什么是人事档案"></a>一、什么是人事档案</h2><p>相信档案大多数人都没怎么重视过，因为人事档案大部分时间自己看不到，由相关部门进行托管。但是人事档案对于工作的人来说是计算工龄的一个重要凭证。其具体定义请参考–<a href="https://baike.baidu.com/item/%E4%BA%BA%E4%BA%8B%E6%A1%A3%E6%A1%88/5046345?fr=aladdin" target="_blank" rel="external">人事档案</a>。这里不再赘述。</p>
<h2 id="二、档案的作用"><a href="#二、档案的作用" class="headerlink" title="二、档案的作用"></a>二、档案的作用</h2><blockquote>
<ul>
<li>转正定级，获取干部身份。必须在第一家单位就业工作满一年，申请转正定级，才会获得干部身份了。干部身份有什么用，请参考–<a href="https://baike.baidu.com/item/%E5%B9%B2%E9%83%A8%E8%BA%AB%E4%BB%BD" target="_blank" rel="external">干部身份</a>；</li>
<li>考研；</li>
<li>考公务员，没有人事档案，没有办法过政审这关；</li>
<li>评职称，如果没有档案，你就没有干部身份，也就没有资格评职称。而职称往往是和工资和户口积分挂钩的。有职称，也是求职的一个砝码！</li>
<li>考资格证，比如会计专业资格考试等，考试需要和人事档案的地点相同，没有人事档案，你报名都可能报不上。</li>
<li>办理准生证，都需要男方存档案的地方开婚育证明；</li>
<li>出国审查，没有档案，政审就无法进行；</li>
<li>养老保险。工龄计算，必须要档案！退休后要拿到退休金，必须要档案，档案是否完备，也将影响到退休金的高低（根据2010年出台的相关文件，自2011年1月1日起，无档案人员也可以以养老保险实际缴纳年限来办理退休手续，但办理过程非常麻烦）；</li>
<li>某些大城市，比如上海，办理居住证，前提是将档案调到上海。没有档案，就没有办法办理居住证，也就没有办法落户上海了；</li>
<li>进国企，事业单位需要档案，而且这是一个非常重要的材料。如果你没有档案且不及时补救，那么这种好单位的大门也会向你关上；</li>
<li>住房补贴发放；</li>
<li>入团入党。</li>
</ul>
</blockquote>
<p>如果档案成为“死档”，以上事件办理将会很麻烦。</p>
<h2 id="三、档案该怎么操作才能不当“弃档族”"><a href="#三、档案该怎么操作才能不当“弃档族”" class="headerlink" title="三、档案该怎么操作才能不当“弃档族”"></a>三、档案该怎么操作才能不当“弃档族”</h2><p>1.毕业后档案不能放在自己手里。可以存放学校、生源地人事局、人才市场、劳动局，街道办事处，职业中介。</p>
<p>2.毕业后自己的第一份工作，如果档案转到单位或当地人才中心，一定要记得干满一年，然后向单位或人才申请转正定级，获得干部身份。</p>
<p>下面结合毕业生的各种情况，谈谈档案的处理方式：</p>
<blockquote>
<ul>
<li>毕业后档案存放学校（注意2年期限）：如果毕业后没有及时找到合适工作（或考研），导致毕业即失业，可以到学校申请暂缓就业，在两年内找到工作的，一定要及时回校办理档案转移，到学校将户籍和档案迁至工作单位所在地或单位所在地的人才市场。两年过后，学校就会打回原籍，很可能造成档案丢失。</li>
<li>毕业后档案存放人才市场（建议）：1)毕业没有找到单位的（或考研），可以去学校或单位所在的人才市场进行档案挂靠，千万不能弃档。人才市场都是人事局办的，是官方机构，这是政府部门，拥有档案保管权，有权办理转正定级，放在那里起码有安全保障。但要提醒的是， 一旦找到工作要及时办理就业手续，以便能够及时的进行转正定级，方便后面的正式调动。如果没有找到工作，也要记得人才交流中心的集体户口是属于临时户口，有两年的限期，毕业超过两年就不能继续托管了，会变成“死档”。一定要记得去处理。可以自己申请打回原籍，以免档案丢失。2)毕业后找到单位的，可放心的找就业地方人才市场挂靠，而且挂靠的人才市场可能会接收个人手上的档案。从存放在人才市场之日开始，就可以算我们的工龄了。就算以后到别的地方发展，也可以通过发调档函，很方便的转到新就业地人才市场。这样既不影响在当地工作，也不影响职称‘晋级’，工龄还能连续计算，顺畅地完成衔接。这里有个注意点是找到的第一份单位工作如果未做满一年，无法请求人才市场进行转正定级，将会失去干部身份。所以如果我们一定要离职，也一定要等到我们的第一份工作做满一年已经申请转正定级获得干部身份后。3)毕业后找到单位后又辞职到其他地方去的，这里还有个注意点：某些地方的人才市场5年内如果没有交档案保管费，人才市场保管档案的义务就会自动解除，档案会被封存，我们的档案会成为“死档”（35岁之前可以档案激活，35岁之后，就麻烦了）！</li>
<li>毕业后档案主动打回原籍（建议）：不管是否参加工作，都可将自己的档案拿回到原籍人事局或人才市场，省的以后麻烦，毕竟以后如果有事情可以让父母帮着处理。把档案放在家乡的人才市场，以后在外地找到工作后不会麻烦,一方面工作又不需要档案，就算是是找到国企、考到公务员，单位发函到你家乡人才市场调档案就可以了。</li>
<li>毕业后档案寄送公司/单位（不太建议）：现在一般公司都是把员工档案统一放在公司所在区的人才市场的。建议档案还是不要归公司管理，以防自己离职的时候档案很有可能被公司扣留。</li>
<li>档案存放在街道办事处（尽量不要）：档案在街道的话，一旦有单位录用你需要调取档案的话比较的麻烦。而且档案放在街道一样要交存档费用。</li>
</ul>
</blockquote>
<h2 id="四、档案成为“死档”的几种原因"><a href="#四、档案成为“死档”的几种原因" class="headerlink" title="四、档案成为“死档”的几种原因"></a>四、档案成为“死档”的几种原因</h2><blockquote>
<ul>
<li>档案丢失会成为“死档”。毕业生择业期为两年，因此择业期间可申请学校代管两年。放在学校两年期满后仍未落实工作的（或找到工作未及时来学校处理的），学校就会将档案和户口一起打回原籍了（或转到学生户口所在地的人才交流中心，或转至生源地所在地级市的人事局或教育局接收）。这里需要强调的是，在打回的过程中很容易把档案搞丢。所以要么两年内去落实工作，要么自己去办理户口和档案转移到某个人才市场或转移到家里去。很多人成为弃档族，就是这里搞丢了！</li>
<li>档案长期在自己手里超过2年，也会成为“死档”。</li>
<li>五年内没有交档案保管费而被人才市场等机构封存的，也会被认为是“死档”。</li>
</ul>
</blockquote>
<h2 id="五、档案不小心成为“死档”的处理方法"><a href="#五、档案不小心成为“死档”的处理方法" class="headerlink" title="五、档案不小心成为“死档”的处理方法"></a>五、档案不小心成为“死档”的处理方法</h2><blockquote>
<ul>
<li>毕业生择业期为两年，如档案遗失，造成没有有按规定办理存档手续而成为“死档”，毕业后未超过2年择业期的（有的地方是3年择业期），可直接去人才市场补办存档手续。超过了择业期，则可以按照非普通高等院校毕业生身份，携带身份证、学历证、户口簿等材料重新办理存档！但前提是不要超过35岁！</li>
<li>把档案留在人才服务机构超过5年没有理会的，只需要补齐代管费、办妥相关手续，就可将档案关系理顺。</li>
<li>自己携带档案要尽快向人才服务机构咨询，如果档案袋被打开，里面的资料需要经过相关部门核实，如果档案资料遗失，还要到原单位去补充和确认。</li>
<li>“跳槽”人员将档案遗留在原单位长期未办理转档手续的，要与原单位协商，解决跳槽后的遗留问题，以便及时将档案转交。</li>
</ul>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 常识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图解TCP/IP三次握手和四次挥手]]></title>
      <url>/2020/05/04/%E5%9B%BE%E8%A7%A3TCP-IP/</url>
      <content type="html"><![CDATA[<p>  <img src="/images/TCP-IP/001Background.jpg" alt="post-cover"><br>参考链接：<a href="https://mp.weixin.qq.com/s/pqUFksNEwT9UWDpcKdGpQg" target="_blank" rel="external">Python开发者公众号-小林coding</a></p>
<hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>不管面试 Java 、C/C++、Python 等开发岗位，TCP的知识点可以说是的必问的了。TCP虐我千百遍，我待TCP如初恋。</p>
<p>本文整理了关于TCP三次握手和四次挥手的面试题型，跟大家一起探讨探讨。</p>
<p><strong>0x00 TCP基本认识</strong></p>
<p>  <img src="/images/TCP-IP/002.png" style="width: 600px;"></p>
<p><strong>0x01 TCP连接建立</strong></p>
<p>  <img src="/images/TCP-IP/003.png" style="width: 600px;"></p>
<p><strong>0x02 TCP连接断开</strong></p>
<p>  <img src="/images/TCP-IP/004.png" style="width: 600px;"></p>
<p><strong>0x03 Socket编程</strong></p>
<p>  <img src="/images/TCP-IP/005.png" style="width: 600px;"></p>
<h2 id="二、TCP基本认识"><a href="#二、TCP基本认识" class="headerlink" title="二、TCP基本认识"></a>二、TCP基本认识</h2><h3 id="瞧瞧TCP头格式"><a href="#瞧瞧TCP头格式" class="headerlink" title="瞧瞧TCP头格式"></a>瞧瞧TCP头格式</h3><p>我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</p>
<p>  <img src="/images/TCP-IP/006.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>序列号:在建立连接时由计算机生成的随机数作为其初始值，通过<code>SYN</code>包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</li>
<li>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题</li>
<li>ACK：该位为1时，「确认应答」的字段变为有效，TCP规定除了最初建立连接时的<code>SYN</code>包之外该位必须设置为1。</li>
<li>RST：该位为1时，表示TCP连接中出现异常必须强制断开连接。</li>
<li>SYC：该位为1时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li>FIN：该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换<code>FIN</code>位置为1的TCP段。</li>
</ul>
</blockquote>
<h3 id="为什么需要TCP协议-TCP工作在哪一层"><a href="#为什么需要TCP协议-TCP工作在哪一层" class="headerlink" title="为什么需要TCP协议?TCP工作在哪一层?"></a>为什么需要TCP协议?TCP工作在哪一层?</h3><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p>  <img src="/images/TCP-IP/007.png" style="width: 400px;"></p>
<p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p>
<h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>  <img src="/images/TCP-IP/008.png" style="width: 300px;"></p>
<blockquote>
<ul>
<li>面向连接：一定是「一对一」才能连接，不能像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li>字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
</blockquote>
<h3 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h3><p>我们来看看<code>RFC 793</code>是如何定义「连接」的：</p>
<blockquote>
<ul>
<li>Connections:<br>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.<br>The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</li>
</ul>
</blockquote>
<p>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为<strong>连接</strong>。</p>
<p>  <img src="/images/TCP-IP/009.png" style="width: 200px;"></p>
<p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p>
<blockquote>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
</blockquote>
<h3 id="如何唯一确定一个TCP连接呢"><a href="#如何唯一确定一个TCP连接呢" class="headerlink" title="如何唯一确定一个TCP连接呢?"></a>如何唯一确定一个TCP连接呢?</h3><p>TCP四元组可以唯一的确定一个连接，四元组包括如下：</p>
<blockquote>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
</blockquote>
<p>  <img src="/images/TCP-IP/010.png" style="width: 500px;"></p>
<p>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过IP协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉TCP协议应该把报文发给哪个进程。</p>
<h3 id="有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？"><a href="#有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？" class="headerlink" title="有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？"></a>有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？</h3><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端IP和端口是可变的，其理论值计算公式如下:</p>
<p>对IPv4，客户端的IP数最多为2^32(IPv4地址理论数量)，客户端的端口数最多为2^16(计算机端口数最大为65535)，也就是服务端单机最大TCP连接数，约为2^48个。</p>
<p>当然，服务端最大并发TCP连接数远不能达到理论上限。</p>
<blockquote>
<ul>
<li>首先主要是文件描述符限制，Socket都是文件，所以首先要通过<code>ulimit</code> 配置文件描述符的数目；</li>
<li>另一个是内存限制，每个TCP连接都要占用一定内存，操作系统内存是有限的。</li>
</ul>
</blockquote>
<h3 id="UDP和TCP有什么区别呢-分别的应用场景是"><a href="#UDP和TCP有什么区别呢-分别的应用场景是" class="headerlink" title="UDP和TCP有什么区别呢?分别的应用场景是?"></a>UDP和TCP有什么区别呢?分别的应用场景是?</h3><p>UDP不提供复杂的控制机制，利用IP提供面向「无连接」的通信服务。</p>
<p>UDP协议真的非常简单，头部只有8个字节(64位)，UDP的头部格式如下：</p>
<p>  <img src="/images/TCP-IP/011.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>
<li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
</blockquote>
<p>TCP和UDP区别：<br>1.连接</p>
<blockquote>
<ul>
<li>TCP是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP不需要建立连接，即刻传输数据。</li>
</ul>
</blockquote>
<p>2.服务对象</p>
<blockquote>
<ul>
<li>TCP是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP支持一对一、一对多、多对多的交互通信。</li>
</ul>
</blockquote>
<p>3.可靠性</p>
<blockquote>
<ul>
<li>TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
</blockquote>
<p>4.拥塞控制、流量控制</p>
<blockquote>
<ul>
<li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率。</li>
</ul>
</blockquote>
<p>5.首部开销</p>
<blockquote>
<ul>
<li>TCP首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是<strong>20</strong>个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP首部只有<strong>8</strong>个字节，并且是固定不变的，开销较小。</li>
</ul>
</blockquote>
<p>TCP和UDP应用场景：</p>
<p>由于TCP是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<blockquote>
<ul>
<li>FTP文件传输</li>
<li>HTTP/HTTPS</li>
</ul>
</blockquote>
<p>由于UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<blockquote>
<ul>
<li>包总量较少的通信，如DNS、SNMP等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
</blockquote>
<h3 id="为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？"><a href="#为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？" class="headerlink" title="为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？"></a>为什么UDP头部没有「首部长度」字段，而TCP头部有「首部长度」字段呢？</h3><p>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。</p>
<h3 id="为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？"><a href="#为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？" class="headerlink" title="为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？"></a>为什么UDP头部有「包长度」字段，而TCP头部则没有「包长度」字段呢？</h3><p>先说说 TCP 是如何计算负载数据长度：</p>
<p>  <img src="/images/TCP-IP/012.png" style="width: 600px;"></p>
<p>其中IP总长度和IP首部长度，在IP首部格式是已知的。TCP首部长度，则是在 TCP首部格式已知的，所以就可以求得TCP数据的长度。</p>
<p>大家这时就奇怪了问：“UDP也是基于IP层的呀，那UDP的数据长度也可以通过这个公式计算呀？为何还要有「包长度」呢？”</p>
<p>这么一问，确实感觉 UDP「包长度」是冗余的。因为为了网络设备硬件设计和处理方便，首部长度需要是<strong>4</strong>字节的整数倍。</p>
<p>如果去掉UDP「包长度」字段，那UDP首部长度就不是<strong>4</strong>字节的整数倍了，所以补充「包长度」字段很可能是为了补全UDP首部长度是<strong>4</strong>字节的整数倍。</p>
<h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><h3 id="TCP三次握手过程和状态变迁"><a href="#TCP三次握手过程和状态变迁" class="headerlink" title="TCP三次握手过程和状态变迁"></a>TCP三次握手过程和状态变迁</h3><p>TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接是通过三次握手而进行的。下图表示TCP三次握手流程:</p>
<p>  <img src="/images/TCP-IP/013.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>一开始，客户端和服务端都处于<code>CLOSED</code>状态。先是服务端主动监听某个端口，处于<code>LISTEN</code>状态。</li>
</ul>
</blockquote>
<p>客户端主动建立连接时发送的第一个报文—<code>SYN报文</code>:</p>
<p>  <img src="/images/TCP-IP/014.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端会随机初始化序号（client_isn），将此序号置于TCP首部的「序号」字段中，同时把<code>SYN</code>标志位置为<strong>1</strong>，表示<code>SYN</code>报文。接着把第一个<code>SYN</code>报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SENT</code>状态。</li>
</ul>
</blockquote>
<p>服务端收到请求后反馈的报文，即三次握手的第二个报文—<code>SYN+ACK报文</code>：</p>
<p>  <img src="/images/TCP-IP/015.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>服务端收到客户端的<code>SYN</code>报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入TCP首部的「序号」字段中，其次把TCP首部的「确认应答号」字段填入client_isn + 1, 接着把<code>SYN</code>和<code>ACK</code>标志位置为 <strong>1</strong>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code>状态。</li>
</ul>
</blockquote>
<p>客户端收到响应后发送的报文，即三次握手的第三个报文—<code>ACK报文</code>:</p>
<p>  <img src="/images/TCP-IP/016.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部<code>ACK</code>标志位置为<strong>1</strong>，其次「确认应答号」字段填入server_isn + 1，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于<code>ESTABLISHED</code>状态。</li>
<li>服务器收到客户端的应答报文后，也进入<code>ESTABLISHED</code>状态。</li>
</ul>
</blockquote>
<p>从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。</p>
<p>一旦完成三次握手，双方都处于<code>ESTABLISHED</code>状态，至此连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h3 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。</p>
<p>  <img src="/images/TCP-IP/017.png" style="width: 800px;"></p>
<h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p>
<p>在前面我们知道了什么是TCP连接：</p>
<blockquote>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</li>
</ul>
</blockquote>
<p>所以，重要的是为什么三次握手才可以初始化Socket、序列号和窗口大小并建立TCP连接。</p>
<p>接下来以三个方面分析三次握手的原因：</p>
<blockquote>
<ul>
<li>三次握手才可以阻止历史重复连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
</blockquote>
<p><strong><em>原因一：避免历史连接</em></strong></p>
<p>我们来看看<code>RFC 793</code>指出的TCP连接使用三次握手的首要原因：</p>
<blockquote>
<ul>
<li>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</li>
</ul>
</blockquote>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下TCP三次握手是如何避免的呢？</p>
<p>  <img src="/images/TCP-IP/018.png" style="width: 600px;"></p>
<p>客户端连续发送多次<code>SYN</code>建立连接的报文，在网络拥堵等情况下：</p>
<blockquote>
<ul>
<li>一个「旧<code>SYN</code>报文」比「最新的<code>SYN</code>」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个SYN + ACK报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送<code>RST</code>报文给服务端，表示中止这一次连接。</li>
</ul>
</blockquote>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<blockquote>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是<code>RST</code>报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报文是<code>ACK</code>报文，通信双方就会成功建立连接；</li>
</ul>
</blockquote>
<p>所以，TCP使用三次握手建立连接的最主要原因是防止历史连接初始化了连接。</p>
<p><strong><em>原因二：同步双方初始序列号</em></strong></p>
<p>TCP协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p>
<blockquote>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
</blockquote>
<p>可见，序列号在TCP连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的<code>SYN</code>报文的时候，需要服务端回一个<code>ACK</code>应答报文，表示客户端的<code>SYN</code>报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p>
<p>  <img src="/images/TCP-IP/019.png" style="width: 600px;"></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><strong><em>原因三：避免资源浪费</em></strong></p>
<p>如果只有「两次握手」，当客户端的<code>SYN</code>请求连接在网络中阻塞，客户端没有接收到<code>ACK</code>报文，就会重新发送<code>SYN</code>，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的<code>ACK</code>确认信号，所以每收到一个<code>SYN</code>就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的<code>SYN</code>阻塞了，重复发送多次<code>SYN</code>报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<p>  <img src="/images/TCP-IP/020.png" style="width: 600px;"></p>
<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求<code>SYN</code>报文，而造成重复分配资源。</p>
<p><strong>小结</strong></p>
<p>TCP建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<blockquote>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
</blockquote>
<h3 id="为什么客户端和服务端的初始序列号-ISN-是不相同的？"><a href="#为什么客户端和服务端的初始序列号-ISN-是不相同的？" class="headerlink" title="为什么客户端和服务端的初始序列号 ISN 是不相同的？"></a>为什么客户端和服务端的初始序列号 ISN 是不相同的？</h3><p>因为网络中的报文会延迟、会复制重发、也有可能丢失，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p>
<h3 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h3><p>起始<code>ISN</code>是基于时钟的，每<strong>4</strong>毫秒 + 1，转一圈要<strong>4.55</strong>个小时。</p>
<p><code>RFC 1948</code>中提出了一个较好的初始化序列号<code>ISN</code>随机生成算法。</p>
<p><strong>ISN = M + F (localhost, localport, remotehost, remoteport)</strong></p>
<blockquote>
<ul>
<li>M是一个计时器，这个计时器每隔<strong>4</strong>毫秒加 1。</li>
<li>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证Hash算法不能被外部轻易推算得出，用MD5算法是一个比较好的选择。</li>
</ul>
</blockquote>
<h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>我们先来认识下<code>MTU</code>和<code>MSS</code>:</p>
<p>  <img src="/images/TCP-IP/021.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>MTU：一个网络包的最大长度，以太网中一般为<strong>1500</strong>字节；</li>
<li>MSS：除去IP 和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度；</li>
</ul>
</blockquote>
<p>如果TCP的整个报文（头部 + 数据）交给IP层进行分片，会有什么异常呢？</p>
<p>当IP层有一个超过MTU大小的数据（TCP 头部 + TCP 数据）要发送，那么IP层就要进行分片，把数据分片成若干片，保证每一个分片都小于<code>MTU</code>。把一份IP数据报进行分片以后，由目标主机的IP层来进行重新组装后，在交给上一层 TCP传输层。</p>
<p>这看起来井然有序，但这存在隐患的，那么当如果一个IP分片丢失，整个IP报文的所有分片都得重传。</p>
<p>因为IP层本身没有超时重传机制，它由传输层的TCP来负责超时和重传。</p>
<p>当接收方发现TCP报文（头部 + 数据）的某一片丢失后，则不会响应<code>ACK</code>给对方，那么发送方的TCP在超时后，就会重发「整个TCP报文（头部 + 数据）」。</p>
<p>因此，可以得知由IP层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的 <code>MSS</code>值，当TCP层发现数据超过<code>MSS</code>时，则就先会进行分片，当然由它形成的IP包的长度也就不会大于<code>MTU</code>，自然也就不用IP分片了。</p>
<p>握手协商<code>MSS</code>:</p>
<p>  <img src="/images/TCP-IP/022.png" style="width: 600px;"></p>
<p>经过TCP层分片后，如果一个TCP分片丢失后，进行重发时也是以<code>MSS</code>为单位，而不用重传所有的分片，大大增加了重传的效率。</p>
<h3 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p><strong>SYN攻击</strong>:我们都知道TCP连接建立是需要三次握手，假设攻击者短时间伪造不同 IP地址的<code>SYN</code>报文，服务端每接收到一个<code>SYN</code>报文，就进入<code>SYN_RCVD</code>状态，但服务端发送出去的ACK + SYN报文，无法得到未知IP主机的<code>ACK</code>应答，久而久之就会占满服务端的SYN接收队列（未连接队列），使得服务器不能为正常用户服务。</p>
<p>  <img src="/images/TCP-IP/023.jpg" style="width: 600px;"></p>
<p><strong>避免 SYN 攻击方式一</strong>:</p>
<p>其中一种解决方式是通过修改Linux内核参数，控制队列大小和当队列满时应做什么处理。</p>
<blockquote>
<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li>
</ul>
</blockquote>
<pre><code>net.core.netdev_max_backlog
</code></pre><blockquote>
<ul>
<li>SYN_RCVD 状态连接的最大个数：</li>
</ul>
</blockquote>
<pre><code>net.ipv4.tcp_max_syn_backlog
</code></pre><blockquote>
<ul>
<li>超出处理能时，对新的<code>SYN</code>直接回<code>RST</code>，丢弃连接：</li>
</ul>
</blockquote>
<pre><code>net.ipv4.tcp_abort_on_overflow
</code></pre><p><strong>避免 SYN 攻击方式二</strong>:</p>
<p>我们先来看下Linux 内核的SYN（未完成连接建立）队列与Accpet（已完成连接建立）队列是如何工作的？</p>
<p>  <img src="/images/TCP-IP/024.png" style="width: 600px;"></p>
<p>正常流程：</p>
<blockquote>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li>
<li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
</blockquote>
<p>  <img src="/images/TCP-IP/025.png" style="width: 600px;"></p>
<p>应用程序过慢：</p>
<blockquote>
<ul>
<li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li>
</ul>
</blockquote>
<p>  <img src="/images/TCP-IP/026.png" style="width: 600px;"></p>
<p>受到 SYN 攻击：</p>
<blockquote>
<ul>
<li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</li>
</ul>
</blockquote>
<p>tcp_syncookies 的方式可以应对 SYN 攻击的方法：</p>
<pre><code>net.ipv4.tcp_syncookies = 1
</code></pre><p>  <img src="/images/TCP-IP/027.png" style="width: 600px;"></p>
<p>tcp_syncookies 应对 SYN 攻击</p>
<blockquote>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li>
<li>计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端；</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」；</li>
<li>最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
</blockquote>
<h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h2><h3 id="TCP四次挥手过程和状态变迁"><a href="#TCP四次挥手过程和状态变迁" class="headerlink" title="TCP四次挥手过程和状态变迁"></a>TCP四次挥手过程和状态变迁</h3><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过四次挥手方式。双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<p>  <img src="/images/TCP-IP/028.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端打算关闭连接，此时会发送一个TCP首部<code>FIN</code>标志位被置为<strong>1</strong>的报文，也即<code>FIN</code>报文，之后客户端进入<code>FIN_WAIT_1</code>状态。</li>
<li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入 <code>CLOSED_WAIT</code>状态。</li>
<li>客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li>
<li>等待服务端处理完数据后，也向客户端发送<code>FIN</code>报文，之后服务端进入<code>LAST_ACK</code>状态。</li>
<li>客户端收到服务端的<code>FIN</code>报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态</li>
<li>服务器收到了<code>ACK</code>应答报文后，就进入了<code>CLOSE</code>状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过<strong>2MSL</strong>一段时间后，自动进入<code>CLOSE</code>状态，至此客户端也完成连接的关闭。</li>
</ul>
</blockquote>
<p>你可以看到，每个方向都需要一个<code>FIN</code>和一个<code>ACK</code>，因此通常被称为四次挥手。这里一点需要注意是：主动关闭连接的，才有<code>TIME_WAIT</code>状态。</p>
<h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发<code>FIN</code>包的过程，就能理解为什么需要四次了。</p>
<blockquote>
<ul>
<li>关闭连接时，客户端向服务端发送<code>FIN</code>时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li>
</ul>
</blockquote>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p>
<h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><strong>MSL</strong>是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，而IP头中有一个TTL字段，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减<strong>1</strong>，当此值为<strong>0</strong>则数据报将被丢弃，同时发送ICMP报文通知源主机。</p>
<p>MSL与TTL的区别：MSL的单位是时间，而TTL是经过路由跳数。所以MSL应该要大于等于TTL消耗为0的时间，以确保报文已被自然消亡。</p>
<p><code>TIME_WAIT</code>等待2倍的MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的<code>ACK</code>报文，就会触发超时重发<code>Fin</code>报文，另一方接收到<code>FIN</code>后，会重发<code>ACK</code>给被动关闭方，一来一去正好2个MSL。</p>
<p>2MSL的时间是从客户端接收到<code>FIN</code>后发送<code>ACK</code>开始计时的。如果在<code>TIME-WAIT</code>时间内，因为客户端的<code>ACK</code>没有传输到服务端，客户端又接收到了服务端重发的<code>FIN</code>报文，那么2MSL时间将重新计时。</p>
<p>在Linux系统里2MSL默认是<strong>60</strong>秒，那么一个MSL也就是30秒。Linux系统停留在<code>TIME_WAIT</code>的时间为固定的60秒。</p>
<p>其定义在Linux内核代码里的名称为<code>TCP_TIMEWAIT_LEN</code>：</p>
<pre><code>#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT state, about 60 seconds  */
</code></pre><p>如果要修改<code>TIME_WAIT</code>的时间长度，只能修改Linux内核代码里 TCP_TIMEWAIT_LEN的值，并重新编译Linux内核。</p>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主动发起关闭连接的一方，才会有<code>TIME-WAIT</code>状态。</p>
<p>需要<code>TIME-WAIT</code>状态，主要是两个原因：</p>
<blockquote>
<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
</blockquote>
<p><strong><em>原因一：防止旧连接的数据包</em></strong></p>
<p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p>  <img src="/images/TCP-IP/029.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的 SEQ = 301 报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
</blockquote>
<p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p>
<p><strong><em>原因二：保证连接正确关闭</em></strong></p>
<p>在<code>RFC 793</code>指出<code>TIME-WAIT</code>另一个重要的作用是：</p>
<blockquote>
<ul>
<li>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</li>
</ul>
</blockquote>
<p>也就是说，<code>TIME-WAIT</code>作用是等待足够的时间以确保最后的<code>ACK</code>能让被动关闭方接收，从而帮助其正常关闭。</p>
<p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p>  <img src="/images/TCP-IP/030.png" style="width: 600px;"></p>
<p>没有确保正常断开的异常</p>
<blockquote>
<ul>
<li>如上图红色框框客户端四次挥手的最后一个<code>ACK</code>报文如果在网络中被丢失了，此时如果客户端<code>TIME-WAIT</code>过短或没有，则就直接进入了<code>CLOSE</code>状态了，那么服务端则会一直处在<code>LASE-ACK</code>状态。</li>
<li>当客户端发起建立连接的<code>SYN</code>请求报文后，服务端会发送<code>RST</code>报文给客户端，连接建立的过程就会被终止。</li>
</ul>
</blockquote>
<p>如果<code>TIME-WAIT</code>等待足够长的情况就会遇到两种情况：</p>
<blockquote>
<ul>
<li>服务端正常收到四次挥手的最后一个<code>ACK</code>报文，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥手的最后一个<code>ACK</code>报文时，则会重发<code>FIN</code>关闭连接报文并等待新的<code>ACK</code>报文。</li>
</ul>
</blockquote>
<p>所以客户端在<code>TIME-WAIT</code>状态等待2MSL时间后，就可以保证双方的连接都可以正常的关闭。</p>
<h3 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h3><p>如果服务器有处于<code>TIME-WAIT</code>状态的 TCP，则说明是由服务器方主动发起的断开请求。</p>
<p>过多的<code>TIME-WAIT</code>状态主要的危害有两种：</p>
<blockquote>
<ul>
<li>第一是内存资源占用；</li>
<li>第二是对端口资源的占用，一个TCP连接至少消耗一个本地端口；</li>
</ul>
</blockquote>
<p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过如下参数设置指定</p>
<pre><code>net.ipv4.ip_local_port_range
</code></pre><p>如果服务端<code>TIME_WAIT</code>状态过多，占满了所有端口资源，则会导致无法创建新连接。</p>
<h3 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h3><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<blockquote>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
</blockquote>
<p>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</p>
<p>如下的 Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。</p>
<pre><code>net.ipv4.tcp_tw_reuse = 1
</code></pre><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<pre><code>net.ipv4.tcp_timestamps = 1 #默认即为1
</code></pre><p>这个时间戳的字段是在TCP头部的「选项」里，用于记录TCP发送方的当前时间戳和从对端接收到的最新时间戳。</p>
<p>由于引入了时间戳，我们在前面提到的2MSL问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p><strong>温馨提醒</strong>：net.ipv4.tcp_tw_reuse要慎用，因为使用了它就必然要打开时间戳的支持 net.ipv4.tcp_timestamps，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。如果不能想到这种可能原因，问题排查将花费大量时间…</p>
<p>方式二：net.ipv4.tcp_max_tw_buckets</p>
<p>这个值默认为<strong>18000</strong>，当系统中处于<code>TIME_WAIT</code>的连接一旦超过这个值时，系统就会将所有的<code>TIME_WAIT</code>连接状态重置。</p>
<p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p>
<p>方式三：程序中使用 SO_LINGER</p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<pre><code>struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));
</code></pre><p>如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个<code>RST</code>标志给对端，该TCP连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP 有一个机制是保活机制。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p>在Linux内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<pre><code>net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9
</code></pre><blockquote>
<ul>
<li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
</blockquote>
<p>也就是说在 Linux 系统中，最少需要经过<strong>2小时11分15秒</strong>才可以发现一个「死亡」连接。</p>
<p>  <img src="/images/TCP-IP/031.png" style="width: 400px;"></p>
<p>这个时间是有点长的，我们也可以根据实际的需求，对以上的保活相关的参数进行设置。</p>
<p>如果开启了TCP保活，需要考虑以下几种情况：</p>
<p>第一种，对端程序是正常工作的。当TCP保活的探测报文发送给对端, 对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间的到来。</p>
<p>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</p>
<p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</p>
<h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><h3 id="针对-TCP-应该如何-Socket-编程？"><a href="#针对-TCP-应该如何-Socket-编程？" class="headerlink" title="针对 TCP 应该如何 Socket 编程？"></a>针对 TCP 应该如何 Socket 编程？</h3><p>  <img src="/images/TCP-IP/032.png" style="width: 600px;"></p>
<p>基于 TCP 协议的客户端和服务器工作</p>
<blockquote>
<ul>
<li>服务端和客户端初始化 socket，得到文件描述符；</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ul>
</blockquote>
<p>这里需要注意的是，服务端调用<code>accept</code>时，连接成功了会返回一个已完成连接的<code>socket</code>，后续用来传输数据。</p>
<p>所以，监听的<code>socket</code>和真正用来传送数据的<code>socket</code>，是「两个」<code>socket</code>，一个叫作监听<code>socket</code>，一个叫作已完成连接<code>socket</code>。</p>
<p>成功连接建立之后，双方开始通过read和write函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h3 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h3><p>Linux内核中会维护两个队列：</p>
<blockquote>
<ul>
<li>未完成连接队列（SYN 队列）：接收到一个<code>SYN</code>建立连接请求，处于<code>SYN_RCVD</code>状态；</li>
<li>已完成连接队列（Accpet 队列）：已完成TCP三次握手过程，处于<code>ESTABLISHED</code>状态；</li>
</ul>
</blockquote>
<p>下图是SYN队列和Accept队列：</p>
<p>  <img src="/images/TCP-IP/033.png" style="width: 600px;"></p>
<pre><code>int listen (int socketfd, int backlog)
</code></pre><blockquote>
<ul>
<li>参数一 socketfd 为 socketfd 文件描述符</li>
<li>参数二 backlog，这参数在历史有一定的变化</li>
</ul>
</blockquote>
<p>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</p>
<p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 backlog 是 accept 队列。</p>
<h3 id="accept-发送在三次握手的哪一步？"><a href="#accept-发送在三次握手的哪一步？" class="headerlink" title="accept 发送在三次握手的哪一步？"></a>accept 发送在三次握手的哪一步？</h3><p>我们先看看客户端连接服务端时，发送了什么？</p>
<p>  <img src="/images/TCP-IP/034.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端的协议栈向服务器端发送了<code>SYN</code>包，并告诉服务器端当前发送序列号client_isn，客户端进入<code>SYNC_SENT</code>状态；</li>
<li>服务器端的协议栈收到这个包之后，和客户端进行<code>ACK</code>应答，应答的值为 client_isn+1，表示对<code>SYN</code>包 client_isn 的确认，同时服务器也发送一个<code>SYN</code>包，告诉客户端当前我的发送序列号为server_isn，服务器端进入<code>SYNC_RCVD</code>状态；</li>
<li>客户端协议栈收到<code>ACK</code>之后，使得应用程序从connect调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为<code>ESTABLISHED</code>，同时客户端协议栈也会对服务器端的<code>SYN</code>包进行应答，应答数据为server_isn+1；</li>
<li>应答包到达服务器端后，服务器端协议栈使得accept阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入<br><code>ESTABLISHED</code>状态。</li>
</ul>
</blockquote>
<p>从上面的描述过程，我们可以得知客户端connect成功返回是在第二次握手，服务端accept成功返回是在三次握手成功之后。</p>
<h3 id="客户端调用-close-了，连接是断开的流程是什么？"><a href="#客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么？"></a>客户端调用 close 了，连接是断开的流程是什么？</h3><p>我们看看客户端主动调用了 close，会发生什么？</p>
<p>  <img src="/images/TCP-IP/035.png" style="width: 600px;"></p>
<blockquote>
<ul>
<li>客户端调用close，表明客户端没有数据需要发送了，则此时会向服务端发送<code>FIN</code>报文，进入<code>FIN_WAIT_1</code>状态；</li>
<li>服务端接收到了<code>FIN</code>报文，TCP协议栈会为<code>FIN</code>包插入一个文件结束符 EOF到接收缓冲区中，应用程序可以通过read调用来感知这个<code>FIN</code>包。这个 EOF会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为EOF表示在该连接上再无额外数据到达。此时，服务端进入<code>CLOSE_WAIT</code>状态；</li>
<li>接着，当处理完数据后，自然就会读到EOF，于是也调用close关闭它的套接字，这会使得会发出一个<code>FIN</code>包，之后处于<code>LAST_ACK</code>状态；</li>
<li>客户端接收到服务端的<code>FIN</code>包，并发送<code>ACK</code>确认包给服务端，此时客户端将进入<code>TIME_WAIT</code>状态；</li>
<li>服务端收到<code>ACK</code>确认包后，就进入了最后的<code>CLOSE</code>状态；</li>
<li>客户端进过2MSL时间之后，也进入<code>CLOSED</code>状态；</li>
</ul>
</blockquote>
<p><strong><em>巨人的肩膀</em></strong></p>
<blockquote>
<ul>
<li>[1] 趣谈网络协议专栏.刘超.极客时间.</li>
<li>[2] 网络编程实战专栏.盛延敏.极客时间.</li>
<li>[3] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社</li>
<li>[4] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社</li>
<li>[5] 图解TCP/IP.竹下隆史.人民邮电出版社</li>
<li>[6] <a href="https://www.rfc-editor.org/rfc/rfc793.html" target="_blank" rel="external">https://www.rfc-editor.org/rfc/rfc793.html</a></li>
<li>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake" target="_blank" rel="external">https://draveness.me/whys-the-design-tcp-three-way-handshake</a></li>
<li>[8] <a href="https://draveness.me/whys-the-design-tcp-time-wait" target="_blank" rel="external">https://draveness.me/whys-the-design-tcp-time-wait</a></li>
</ul>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> Internet Protocol </tag>
            
            <tag> TCP-IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针浅谈]]></title>
      <url>/2020/05/04/%E6%8C%87%E9%92%88%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<p><img src="/images/Pointer/Pointer_Background.jpg" alt="post-cover"></p>
<p>此篇博客是由日常阅读、总结的文章，旨在通过通俗易懂的文字理解C/C++中的指针。<br>目录一览：</p>
<blockquote>
<ul>
<li>什么是指针</li>
<li>指针与数组</li>
<li>new和delete，申请、释放内存空间</li>
</ul>
</blockquote>
<hr>
<h2 id="一、什么是指针？"><a href="#一、什么是指针？" class="headerlink" title="一、什么是指针？"></a>一、什么是指针？</h2><!-- &nbsp;表示一个空格 -->
<p>首先，提一句我看到过的让我理解指针最形象的比喻：<strong>变量和指向该变量的指针是同一个硬币的两面</strong>。我们从以下代码片段进行阐述：</p>
<pre><code>int value = 5;//①
int* pointer = &amp;value;//②
cout &lt;&lt; pointer &lt;&lt; endl;//③
cout &lt;&lt; *pointer &lt;&lt; endl;//④
</code></pre><blockquote>
<ul>
<li>①表示变量value的值是5，数据类型int，int类型占用存储空间一般是4个字节，因为计算机世界里只有0和1，所以变量value在<code>大端模式</code>的计算机世界里是长这个样子的:00000000 00000000 00000000 00000101,其中8个bit表示1个byte。不同的数据类型，其存储空间大小不一样，可以理解为不同大小的鞋子应该放在不同大小的鞋盒里面。value存储在计算机某块内存中，内存地址对程序员不直接可见，这里假设我们使用的机器是32位的，并假设变量value的内存地址的值的16进制表示为0x12345678</li>
<li>②表示指针变量pointer指向变量value的地址，可以把这一行中的＆符号理解为”取地址操作”，只有取地址操作后，等于号”=”右边的值才是指针类型，类型相同才能赋值这是基础语法。</li>
<li>③是C++语法的输出语句，效果同C中println，其输出值为0x12345678，说明指针变量的值就是它所指向的变量value的内存地址的值，pointer既然也称之为变量，那就一定也要占据存储空间，指针的大小由<code>内存寻址空间</code>决定（即x86还是x64），刚才说pointer的值是0x12345678，所以它在大端模式计算机里长这样:00010010 00110100 01010110 01111000</li>
<li>④也是输出语句，输出值为5，表示指针变量pointer所指向的那个地址的实际存储的内容是整数5，这里<code>*</code>符号理解为”解引用操作”，意思就是把pointer指针指向的地址的值取出来。</li>
</ul>
</blockquote>
<p>所以，实际上，指针变量pointer的值是变量value的地址，变量value的值既可以用指向它自己的指针通过”解引用操作”表示，又能用该变量自己表示。</p>
<p><strong><em>那为什么需要指针这个概念呢？</em></strong></p>
<p>我个人的理解是便于操作，减少变量，因为指针也可以加1减1这样操作的，比如说上面提到的指针pointer+1，结果将是0x1234567C，因为pointer存储空间是4个字节，它加1相当于把它指向的地址往后移动4个字节(16进制的8加上4等于C，不需要进位，所以前面的7不变)，假如我有一万个在存储空间中相邻排布的相同类型的变量，我可以用一个该类型的指针变量表示这一万个值，因为我移动该指针的地址就行了，然后”解引用操作”取出该地址存储的值。你可能会说我也可以用a表示所有啊，a=3，用完之后a=4，并非如此，你说的这个a在它的作用域内的地址是固定的，从3改为4是指把a实际存储的值变化了，用指针当然也可以改变其中实际的值，不过更多的是通过一个指针变量取出存储在不同地址的值。另外值得一提到是，上面说的指针变量pointer，刚才只说了它的值是value的地址，那它肯定也有自己的地址啊，没错，它肯定也有地址，它的地址将会是某个二级指针的值，也就是<code>**</code>这个玩意儿了。</p>
<hr>
<p><strong>脚下留心：</strong></p>
<p><strong>1.大端模式与小端模式</strong></p>
<p>大小端的问题是由CPU决定的，它表示的是对内存中排布的数据的不同解析方式。</p>
<p>假设一个占4个byte的int类型变量的值固定是0x12345678（其中我们称12在高字节位，78在低字节位）。如果该变量在内存空间中如下排布（其中我们称0x100在低地址位，0x103在高地址位），则表示高字节位的12排布在低地址0x100上，说明此款CPU是以大端方式进行解析的。</p>
<table>
<thead>
<tr>
<th>数据存储地址</th>
<th style="text-align:center">…</th>
<th style="text-align:center">0x100</th>
<th style="text-align:center">0x101</th>
<th style="text-align:center">0x102</th>
<th style="text-align:center">0x103</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据存储值</strong></td>
<td style="text-align:center"><strong>…</strong></td>
<td style="text-align:center"><strong>12</strong></td>
<td style="text-align:center"><strong>34</strong></td>
<td style="text-align:center"><strong>56</strong></td>
<td style="text-align:center"><strong>78</strong></td>
<td><strong>…</strong></td>
</tr>
</tbody>
</table>
<p>如果该变量在内存空间中如下排布，则表示高字节位的12排布在高地址0x103上，说明此款CPU是以小端方式进行解析的。</p>
<table>
<thead>
<tr>
<th>数据存储地址</th>
<th style="text-align:center">…</th>
<th style="text-align:center">0x100</th>
<th style="text-align:center">0x101</th>
<th style="text-align:center">0x102</th>
<th style="text-align:center">0x103</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据存储值</strong></td>
<td style="text-align:center"><strong>…</strong></td>
<td style="text-align:center"><strong>78</strong></td>
<td style="text-align:center"><strong>56</strong></td>
<td style="text-align:center"><strong>34</strong></td>
<td style="text-align:center"><strong>12</strong></td>
<td><strong>…</strong></td>
</tr>
</tbody>
</table>
<p><strong>2.内存寻址空间</strong></p>
<p>我们都听说过x86操作系统和x64操作系统的概念，其实就是说32位和64位操作系统，但与之对应的应该是硬件处理器CPU，操作系统本质上还是一款软件，它的绝对性能取决于底层硬件设备。什么是内存寻址空间？我们知道32位的CPU连接32根地址线，那么它总共可以表示2^32个内存地址，每个内存地址指向内存中的一个byte，所以总共2^32bytes=4G，即32位的电脑最多可利用的内存空间是4G，亦即32位的电脑只需配4G的内存条就够了，多了也是浪费，根本利用不上。</p>
<hr>
<h2 id="二、指针与数组"><a href="#二、指针与数组" class="headerlink" title="二、指针与数组"></a>二、指针与数组</h2><p>惯例，先上代码段：</p>
<pre><code>int arrayA[3] = {6, 7, 8};//①
int* p_arrayA = arrayA;//②
</code></pre><blockquote>
<ul>
<li>①是初始化一个长度为3的int型数组<code>arrayA</code></li>
<li>②是将一个int类型指针<code>p_arrayA</code>指向该数组</li>
</ul>
</blockquote>
<p>这两行代码不报错说明什么呢？说明数组名其实可以当做指针，该指针指向本数组中首个元素，即6所在的地址，而指针<code>p_arrayA</code>也指向数组的首个元素的地址。</p>
<p><em>它俩有什么区别？</em></p>
<blockquote>
<ul>
<li>指针的值可修改，而数组名是常量。这里提到常量，常量指不可更改的值，比如说出生日期。常量相对而言的是变量，比如说年龄。刚才提到的<code>p_arrayA</code>是变量，<code>arrayA</code>是常量对应代码的表现就是:<br><code>p_arrayA = p_arrayA + 1； // 合理</code><br><code>arrayA = arrayA + 1；// 报错</code><br>虽然不能显式的给<code>arrayA</code>重新赋值，但是用它来取值是可以的，比如说<code>arrayA[1]</code>和<code>*(arrayA+1)</code>都是数组<code>arrayA</code>的第二个变量的值，即7。</li>
<li>对数组名应用sizeof运算符得到的是该数组的占用内存空间的大小(单位是byte)，对指针应用sizeof运算符得到的是该类型的指针变量的大小。<br><em>为什么说sizeof是运算符？</em><br>因为sizeof返回的单位是byte，即变量实际占用的内存大小，而<code>size（）</code>或者<code>length（）</code>这样的函数返回值一般是数组的长度，即数组成员是多少个。</li>
</ul>
</blockquote>
<p>综上，数组名<code>arrayA</code>可以当做指针用，所以以后看到<code>*(arrayA++)</code>这样的代码不要奇怪。最后，我曾经自己写例子得到指向<code>&amp;arrayA</code>的指针是一个<code>int(*)[3]</code>类型的，<code>int(*)[3]</code>可以理解为长度为3的int类型数组的指针。</p>
<hr>
<h2 id="三、new和delete，申请、释放内存空间"><a href="#三、new和delete，申请、释放内存空间" class="headerlink" title="三、new和delete，申请、释放内存空间"></a>三、new和delete，申请、释放内存空间</h2><p>C++中使用new和delete关键字对内存进行分配和回收，C中使用malloc和free。</p>
<p><strong><em>1.使用new申请的内存空间为什么需要用delete释放？</em></strong></p>
<p>举个例子：</p>
<p>你租用了政府一块地（new），并在上面盖了个房子（初始化），并在里面住了一段时间，做了一些事情（使用）。当你使用期限到了， 你应该把地归还政府（delete），公有制不是你想造作就能造作的，人人都申请不归还，白嫖？难不成你想被请去喝茶（计算机资源有限）。</p>
<p><strong><em>2.被delete了的内存空间为什么不要再使用？</em></strong></p>
<p>接上一个例子：</p>
<p>你把地归还给政府后，政府这时只是登记一下，某块地现在已经空闲了，它并不会去清除那块地上的房子，但政府随时可能把地提供给其他大老板，虽然房子可能暂时还没拆，但如果你继续住在里面的话（访问已释放的内存），你随时都可能在梦中被推土机碾成肉酱。</p>
<p><strong><em>3.delete一定要作用于被new的那个变量吗？</em></strong></p>
<p>不是，delete只要作用于被new的地址就行了。<br>比如以下代码段：</p>
<pre><code>int* ps = new int；// allocate memory
int* pq = ps;// set second pointer to same block
delete pq;// delete with second pointer
ps = NULL;
pq = NULL;
</code></pre><p>以上代码仍然可以释放被new申请的内存空间，而不一定非要<code>delete ps;</code>。</p>
<p><strong><em>4.接上一个代码段，为什么要将指针变量显式地置为NULL？</em></strong></p>
<p>delete一个指针后，编译器只会释放该指针指向的内存空间，而不会删除这个指针本身，且指针重新指向一个未知地址，置为NULL之后再次使用该指针编译器将报错，可以避免后续代码无意使用该指针造成的难以预料的问题，即避免问题2中提到的“被碾成肉酱”。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 个人小结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Internet Protocol(1)]]></title>
      <url>/2017/08/12/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE(%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%A7%92%E5%BA%A6%E8%A7%A3%E8%AF%BB)/</url>
      <content type="html"><![CDATA[<p>  <img src="/images/InternetProtocol/Background.jpg" alt="post-cover"><br>参考链接：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">阮一峰前辈的学习博客</a></p>
<hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>你是否有过疑惑，全球几十亿台计算机是<code>如何</code>通过互联网实现信息传递的？</p>
<p>下面是我参考各前辈的学习笔记写下的关于互联网协议的文章。因为这些协议实在太复杂、太庞大，在这里整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，其中做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。</p>
<hr>
<h2 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h2><h3 id="2-1-七层模型"><a href="#2-1-七层模型" class="headerlink" title="2.1 七层模型"></a>2.1 七层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p>
<p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p>
<p>下面是ISO定义网络的标准层次模型。</p>
<p>  <img src="/images/InternetProtocol/one.png" style="width: 800px;"></p>
<p>如上图所示，最底下的一层叫做”物理层”-<code>Physical Layer</code>，最上面的一层叫做”应用层”-<code>Application Layer</code>，中间的五层（自下而上）分别是”链接层”-<code>Link Layer</code>、”网络层”-<code>Network Layer</code>、”传输层”-<code>Transport Layer</code>、”会话层”-<code>Session Layer</code>和”表现层”-<code>Presentation layer</code>。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p>
<h3 id="2-2-层与协议"><a href="#2-2-层与协议" class="headerlink" title="2.2 层与协议"></a>2.2 层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p>
<p>大家都遵守的规则，就叫做”协议”-<code>protocol</code>。</p>
<p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”-<code>Internet Protocol Suite</code>。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p>
<hr>
<h2 id="三、物理层"><a href="#三、物理层" class="headerlink" title="三、物理层"></a>三、物理层</h2><p>我们从最底下的一层开始。</p>
<p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p>
<p>  <img src="/images/InternetProtocol/two.png" style="width: 600px;"></p>
<p><strong>这就叫做”物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>
<hr>
<h2 id="四、链接层"><a href="#四、链接层" class="headerlink" title="四、链接层"></a>四、链接层</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p><strong>这就是”链接层”的功能，它在”物理层”的上方，确定了0和1的分组方式。</strong></p>
<h3 id="4-2-以太网协议"><a href="#4-2-以太网协议" class="headerlink" title="4.2 以太网协议"></a>4.2 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="external">以太网</a>“-<code>Ethernet</code>的协议，占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做”<a href="https://zh.wikipedia.org/wiki/%E5%B8%A7" target="_blank" rel="external">帧</a>“-<code>Frame</code>。每一帧分成两个部分：标头-<code>Head</code>和数据-<code>Data</code>。</p>
<p>  <img src="/images/InternetProtocol/three.png" style="width: 600px;"></p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="4-3-MAC地址"><a href="#4-3-MAC地址" class="headerlink" title="4.3 MAC地址"></a>4.3 MAC地址</h3><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做<code>MAC</code>地址。</p>
<p>  <img src="/images/InternetProtocol/four.jpg" style="width: 450px;"></p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的<code>MAC</code>地址，长度是48个二进制位，通常用12个<code>十六进制</code>数表示。</p>
<p>  <img src="/images/InternetProtocol/five.png" style="width: 450px;"></p>
<p>前6个<code>十六进制</code>数是厂商编号，后6个是该厂商的网卡流水号。有了<code>MAC</code>地址，就可以定位网卡和数据包的路径了。</p>
<h3 id="4-4-广播"><a href="#4-4-广播" class="headerlink" title="4.4 广播"></a>4.4 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p>
<p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p>
<p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的<code>MAC</code>地址，然后才能发送。</p>
<p>其次，就算有了<code>MAC</code>地址，系统怎样才能把数据包准确送到接收方？</p>
<p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<p>  <img src="/images/InternetProtocol/six.png" style="width: 600px;"></p>
<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的<code>MAC</code>地址，然后与自身的<code>MAC</code>地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”<a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF" target="_blank" rel="external">广播</a>“-<code>broadcasting</code>。</p>
<p>有了数据包的定义、网卡的<code>MAC</code>地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p>
<hr>
<h2 id="五、网络层"><a href="#五、网络层" class="headerlink" title="五、网络层"></a>五、网络层</h2><h3 id="5-1-网络层的由来"><a href="#5-1-网络层的由来" class="headerlink" title="5.1 网络层的由来"></a>5.1 网络层的由来</h3><p>以太网协议，依靠<code>MAC</code>地址发送数据。理论上，单单依靠<code>MAC</code>地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p>
<p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p>
<p>  <img src="/images/InternetProtocol/seven.png" style="width: 600px;"></p>
<p>因此，必须找到一种方法，能够区分哪些<code>MAC</code>地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，<code>MAC</code>地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是<code>MAC</code>地址，另一种是网络地址。两种地址之间没有任何联系，<code>MAC</code>地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，<code>MAC</code>地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理<code>MAC</code>地址。</p>
<h3 id="5-2-IP协议"><a href="#5-2-IP协议" class="headerlink" title="5.2 IP协议"></a>5.2 IP协议</h3><p>规定网络地址的协议，叫做<code>IP</code>协议。它所定义的地址，就被称为<code>IP</code>地址。</p>
<p>目前，广泛采用的是<code>IP</code>协议第四版，简称IPv4。这个版本规定，网络地址由32个<code>二进制</code>位组成。</p>
<p>  <img src="/images/InternetProtocol/eight.png" style="width: 450px;"></p>
<p>习惯上，我们用分成四段的十进制数表示<code>IP</code>地址，从<strong>0.0.0.0</strong>一直到<strong>255.255.255.255</strong>。</p>
<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，<code>IP</code>地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>
<p>但是，问题在于单单从<code>IP</code>地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从<code>IP</code>地址上是看不出来的。</p>
<p>那么，怎样才能从<code>IP</code>地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%BD%91#.E7.BD.91.E7.BB.9C.E6.8E.A9.E7.A0.81" target="_blank" rel="external">子网掩码</a>“-<code>subnet mask</code>。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，<code>IP</code>地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个<code>IP</code>地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是<strong>255.255.255.0</strong>，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p><strong>总结一下，<code>IP</code>协议的作用主要有两个，一个是为每一台计算机分配<code>IP</code>地址，另一个是确定哪些地址在同一个子网络。</strong></p>
<h3 id="5-3-IP数据包"><a href="#5-3-IP数据包" class="headerlink" title="5.3 IP数据包"></a>5.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做<code>IP</code>数据包。不难想象，其中必定包括<code>IP</code>地址信息。</p>
<p>但是前面说过，以太网数据包只包含<code>MAC</code>地址，并没有<code>IP</code>地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p>
<p>回答是不需要，我们可以把<code>IP</code>数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p>
<p>具体来说，<code>IP</code>数据包也分为”标头”和”数据”两个部分。</p>
<p>  <img src="/images/InternetProtocol/nine.png" style="width: 600px;"></p>
<p>“标头”部分主要包括版本、长度、<code>IP</code>地址等信息，”数据”部分则是<code>IP</code>数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p>
<p>  <img src="/images/InternetProtocol/ten.png" style="width: 600px;"></p>
<p><code>IP</code>数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个<code>IP</code>数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果<code>IP</code>数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h3 id="5-4-ARP协议"><a href="#5-4-ARP协议" class="headerlink" title="5.4 ARP协议"></a>5.4 ARP协议</h3><p>关于”网络层”，还有最后一点需要说明。</p>
<p>因为<code>IP</code>数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的<code>MAC</code>地址，另一个是对方的<code>IP</code>地址。通常情况下，对方的<code>IP</code>地址是已知的（后文会解释），但是我们不知道它的<code>MAC</code>地址。</p>
<p>所以，我们需要一种机制，能够从<code>IP</code>地址得到<code>MAC</code>地址。</p>
<p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的<code>MAC</code>地址，只能把数据包传送到两个子网络连接处的”<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3" target="_blank" rel="external">网关</a>“-<code>gateway</code>，让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的<code>MAC</code>地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的<code>IP</code>地址，在对方的<code>MAC</code>地址这一栏，填的是<strong>FF:FF:FF:FF:FF:FF</strong>，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出<code>IP</code>地址，与自身的<code>IP</code>地址进行比较。如果两者相同，都做出回复，向对方报告自己的<code>MAC</code>地址，否则就丢弃这个包。</p>
<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机<code>MAC</code>地址，可以把数据包发送到任意一台主机之上了。</p>
<hr>
<h2 id="六、传输层"><a href="#六、传输层" class="headerlink" title="六、传输层"></a>六、传输层</h2><h3 id="6-1-传输层的由来"><a href="#6-1-传输层的由来" class="headerlink" title="6.1 传输层的由来"></a>6.1 传输层的由来</h3><p>有了<code>MAC</code>地址和<code>IP</code>地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%9F%A0" target="_blank" rel="external">端口</a>“-<code>port</code>，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</strong>因此，Unix系统就把主机+端口，叫做”<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7" target="_blank" rel="external">套接字</a>“-<code>socket</code>。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="6-2-UDP协议"><a href="#6-2-UDP协议" class="headerlink" title="6.2 UDP协议"></a>6.2 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由”标头”和”数据”两部分组成。</p>
<p>  <img src="/images/InternetProtocol/eleven.png" style="width: 600px;"></p>
<p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入<code>IP</code>数据包的”数据”部分，而前面说过，<code>IP</code>数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p>
<p>  <img src="/images/InternetProtocol/twelve.png" style="width: 600px;"></p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个<code>IP</code>数据包。</p>
<h3 id="6-3-TCP协议"><a href="#6-3-TCP协议" class="headerlink" title="6.3 TCP协议"></a>6.3 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在<code>IP</code>数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<hr>
<h2 id="七、会话层"><a href="#七、会话层" class="headerlink" title="七、会话层"></a>七、会话层</h2><p>会话层利用传输层来提供会话服务，会话可能是一个用户通过网络登录到一个主机，或一个正在建立的用于传输文件的会话。<br>会话层的功能主要有：会话连接到传输连接的映射、数据传送、会话连接的恢复和释放、会话管理、令牌管理和活动管理。 </p>
<hr>
<h2 id="八、表示层"><a href="#八、表示层" class="headerlink" title="八、表示层"></a>八、表示层</h2><p>表示层用于数据管理的表示方式，如用于文本文件的ASCII和EBCDIC，用于表示数字的1S或2S补码表示形式。如果通信双方用不同的数据表示方法，他们就不能互相理解。表示层就是用于屏蔽这种不同之处。<br>表示层的功能主要有：数据语法转换、语法表示、表示连接管理、数据加密和数据压缩。 </p>
<hr>
<h2 id="九、应用层"><a href="#九、应用层" class="headerlink" title="九、应用层"></a>九、应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>
<p>  <img src="/images/InternetProtocol/thirteen.png" style="width: 600px;"></p>
<p>至此，整个互联网的七层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> Internet Protocol </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建网站教程]]></title>
      <url>/2017/08/06/Hexo/</url>
      <content type="html"><![CDATA[<p><img src="/images/Background.jpg" alt="post-cover"></p>
<p>这是第一篇博客，主要介绍hexo搭建网站的过程<br><a id="more"></a></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title=" 1.前言"></a> 1.前言</h1><p><strong>使用github pages服务搭建博客的好处有：</strong></p>
<blockquote>
<p>1.全是静态文件访问速度快<br>  2.免费方便，不花一分钱就能搭建一个自由的个人博客<br>  3.可以绑定自己的域名，不仔细看看不出是github的</p>
</blockquote>
<h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title=" 1.1  准备工作"></a> 1.1  准备工作</h2><blockquote>
<p><strong>注意：</strong>在开始一切之前，你必须已经：</p>
<ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
</blockquote>
<p> <strong>本文所使用的环境：</strong></p>
<blockquote>
<ul>
<li>window8.1 x 64</li>
<li>node.js    6.11.x</li>
<li>git     2.12.x</li>
<li>hexo   </li>
</ul>
</blockquote>
<h1 id="2-搭建github博客"><a href="#2-搭建github博客" class="headerlink" title=" 2.搭建github博客"></a> 2.搭建github博客</h1><h2 id="2-1创建仓库"><a href="#2-1创建仓库" class="headerlink" title=" 2.1创建仓库"></a> 2.1创建仓库</h2><blockquote>
<p>1.新建一个名字为<code>你的用户名.github.io</code>的仓库,以我自己的用户名为例,我的用户名为JiangLingJun，那么我的仓库名就是<code>JiangLingJun.github.io</code><br>2.你将来的博客的网址即为 <a href="https://JiangLingJun.github.io" target="_blank" rel="external">https://JiangLingJun.github.io</a></p>
</blockquote>
<p>脚下留心：</p>
<blockquote>
<p>1.注册邮箱一定要验证，否则建不了仓库<br>2.仓库名称必须是： <code>你的用户名.github.io</code>,其中你的用户名必须和你登录的一样<br>3.仓库的创建不会立即生效，有可能需要等10~30分钟，或者更久</p>
</blockquote>
<h2 id="2-2绑定域名"><a href="#2-2绑定域名" class="headerlink" title="2.2绑定域名"></a>2.2绑定域名</h2><ul>
<li>你不绑定域名也是可以的，那你就默认访问 xxx.github.io就好</li>
<li>但是我们都想个性一点，拥有我们自己的域名不是吗？我这里用的是阿里云购买的一个域名，价格也不太贵，对学生还有优惠。</li>
<li><p>域名绑定有2种方式，CNAME和A记录，CNAME是要填写域名的，A是要填写IP 的。<br>1.A记录型（填写ip），你需要ping一下 <code>你的用户名.github.io</code> 然后将ip地址和域名进行绑定<br>2.CNAME型（填写域名），需要你将自己的域名和github的域名进行 绑定<br><img src="/images/CreateMyBlog01.png" style="width: 600px;"></p>
<p>然后你要到自己的github项目的根目录下新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你的喜好，因为经过测试</p>
</li>
</ul>
<blockquote>
<ul>
<li>如果你填写的是没有www的，比如 yoursite.xyz 那么无论访问 <a href="http://yoursize.xyz" target="_blank" rel="external">http://yoursize.xyz</a> 还是 <a href="http://yoursite.xyz" target="_blank" rel="external">http://yoursite.xyz</a> 都会自动跳转到 <a href="http://yoursite.xyz" target="_blank" rel="external">http://yoursite.xyz</a></li>
<li>如果你写的是带www的，比如  www.yoursite.xyz  那么无论是访问 <a href="http://www.yoursite.xyz" target="_blank" rel="external">http://www.yoursite.xyz</a> 还是 <a href="http://yoursite.xyz都会自动跳转到" target="_blank" rel="external">http://yoursite.xyz都会自动跳转到</a> <a href="http://www.yoursite.xyz" target="_blank" rel="external">http://www.yoursite.xyz</a></li>
<li>如果你填写其他的子域名，比如 aaa.yoursite.xyz ,那么访问 <a href="http://aaa.yoursite.xyz" target="_blank" rel="external">http://aaa.yoursite.xyz</a> 没有问题，但是访问 <a href="http://yoursite.xyz" target="_blank" rel="external">http://yoursite.xyz</a> 不会跳转到 <a href="http://abc.yoursite.xyz" target="_blank" rel="external">http://abc.yoursite.xyz</a></li>
</ul>
</blockquote>
<p>补充：在绑定域名后，原来的域名<code>你的用户名.github.io</code>，没有失效而是会自动跳转的你的新域名。</p>
<h1 id="3-配置-SSH-key"><a href="#3-配置-SSH-key" class="headerlink" title="3.配置 SSH key"></a>3.配置 SSH key</h1><p>配置原因：提交代码到github需要权限，但是直接使用用户名和密码 不安全，我们使用ssh key来解决本地和服务器之间的连接问题</p>
<pre><code>$cd ~/.ssh  #检查本地存在的ssh秘钥
</code></pre><p>如果提示：No such file or directory 说明你是第一次使用git</p>
<pre><code>ssh-keygen -t rsa -C &quot;邮箱地址&quot;
</code></pre><p>然后连续3次回车，最终会生成ssh key在用户的目录下，打开你自己的用户目录 ，在里面找到 .ssh\id_rsa.pub 文件，记事本打开，并且复制里面内容，然后打开你的github主页， 进入个人设置 –》 SSH and GPG keys – 》 New SSH key<br><img src="/images/CreateMyBlog02.png" style="width: 600px;"></p>
<p>然后将刚复制的内容粘贴到key那里，title随便填，保存</p>
<h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><pre><code>$ ssh -T git@github.com
</code></pre><p>如果提示<code>Are you sure you want to continue to connecting(yes/no)?</code>,然后输入yes，然后会看到</p>
<blockquote>
<p>hi ，xxx ! You’ve successfully authenticated , but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个说明SSH配置成功<br>此时你还需要配置：</p>
<pre><code>$ git config --global user.name &quot;xxx&quot;  # 你的github用户名
$ git config --global user.email &quot;xxx&quot;   # 你的邮箱名 
</code></pre><h1 id="4-使用hexo写博客"><a href="#4-使用hexo写博客" class="headerlink" title="4.使用hexo写博客"></a>4.使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1 hexo简介"></a>4.1 hexo简介</h2><p>hexo 是一个简单、快速、强大的基于github pages 的博客发布工具，支持Markdown格式，有许多优秀插件和主题</p>
<p>官网：  <a href="http://hexo.io" target="_blank" rel="external">http://hexo.io</a><br>github :  <a href="https://github.com/hexojs/hexo" target="_blank" rel="external">https://github.com/hexojs/hexo</a></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2 原理"></a>4.2 原理</h2><p>   由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
<h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h2><p>脚下留心：</p>
<blockquote>
<p>1.很多命令既可以用windows的cmd来完成，也可以用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；<br>2.hexo不同版本的差别较大，网上很多文章是基于2.x的，不要被误导<br>3.hexo有两种_config.yml文件，一个是根目录下的全局的_config.yml,一个是themes下的</p>
</blockquote>
<h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4 安装"></a>4.4 安装</h2><p>注意要先安装 node.js ，这里不再详细说明</p>
<pre><code>$npm install -g hexo
</code></pre><h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5 初始化"></a>4.5 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是 F:\Hexo ,由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<pre><code>$cd /f/Hexo 
$hexo  init
</code></pre><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p>
<p><img src="/images/CreateMyBlog03.png" style="width: 600px;"></p>
<pre><code>$hexo g #生成
$hexo s #启动服务
</code></pre><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p>
<p><img src="/images/CreateMyBlog04.png" style="width: 600px;"><br>hexo s是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p>
<p><a href="http://blog.liuxianan.com/windows-port-bind.html" target="_blank" rel="external">http://blog.liuxianan.com/windows-port-bind.html</a></p>
<p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p>
<p><img src="/images/CreateMyBlog05.png" style="width: 600px;"></p>
<h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6 修改主题"></a>4.6 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="external">官方主题</a></p>
<p>我自己选的主题 <a href="https://github.com/Haojen/hexo-theme-Claudia.git" target="_blank" rel="external">hexo-theme-Claudia</a></p>
<p>首先下载这个主题：</p>
<pre><code>$ cd /d/Hexo
$ git clone https://github.com/Haojen/hexo-theme-Claudia.git  themes/Claudia
</code></pre><p>下载后的主题在这里：</p>
<p><img src="/images/CreateMyBlog06.png" style="width: 600px;"></p>
<p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: Claudia</code>，然后重新执行hexo g来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p>
<h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7 上传之前"></a>4.7 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p>
<h2 id="4-8-上传到github上"><a href="#4-8-上传到github上" class="headerlink" title="4.8 上传到github上"></a>4.8 上传到github上</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p>
<p>首先，ssh key肯定要配置好。</p>
<p>其次，配置_config.yml中有关deploy的部分：</p>
<p>正确写法：</p>
<pre><code>deploy:
    type: git
    repository: git@github.com:你的用户名/你的用户名.github.io.git
    branch: master
</code></pre><p>脚下留心： <strong>type及后面的repository，branch的冒号后面一定要有空格</strong></p>
<p>直接执行<code>hexo d</code>的话一般会报如下错误：</p>
<pre><code>Deployer not found: github 或者 Deployer not found: git
</code></pre><p>原因是需要安装一个插件，部署这个命令一定要用git bash：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>最后输入<code>hexo d</code>将代码全部提交到github上。</p>
<h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10 常用hexo命令"></a>4.10 常用hexo命令</h2><pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
</code></pre><h1 id="5-博客的编写"><a href="#5-博客的编写" class="headerlink" title="5 博客的编写"></a>5 博客的编写</h1><h2 id="5-1-博客一般格式"><a href="#5-1-博客一般格式" class="headerlink" title="5.1 博客一般格式"></a>5.1 博客一般格式</h2><pre><code> ---
 title: postName #文章页面上的显示名称，一般是中文
 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改
 categories: 默认分类 #分类
 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格
 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
 ---

以下是正文
</code></pre><h2 id="5-2-正文的编写语法"><a href="#5-2-正文的编写语法" class="headerlink" title="5.2 正文的编写语法"></a>5.2 正文的编写语法</h2><p> 我这里用的Markdown，用的软件是一款在线编辑工具<a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a>，当然网上还有许多编辑工具，大家可以自己去查</p>
<h2 id="最后的说明–编辑文件的位置：source下的posts下的md文件"><a href="#最后的说明–编辑文件的位置：source下的posts下的md文件" class="headerlink" title=" 最后的说明–编辑文件的位置：source下的posts下的md文件"></a> 最后的说明–编辑文件的位置：source下的posts下的md文件</h2><p>本文的参考文章:<a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="external">http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>
<p>详细的编写博客的教程，可以去百度：hexo编写博客</p>
]]></content>
      
        
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 个人网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/03/hello-world/</url>
      <content type="html"><![CDATA[<p><img src="/images/HelloWorld.jpg" alt="post-cover"></p>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> foo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
